{"version":3,"sources":["game/draw-functions.ts","canvas/canvas-styles.tsx","canvas/canvas.tsx","game/sprite.ts","game/object.ts","images/enemy/enemy_1.png","images/enemy/enemy_2.png","game/enemy.ts","game/player.ts","images/player/player_idle.png","images/player/player_shooting.png","images/player/player_running_1.png","images/player/player_running_2.png","images/player/player_dead.png","game/index.ts","game/projectile.ts","game/helper-functions.ts","game/game-state.ts","App.tsx","menu/menu-styles.tsx","menu/in-game-menu.tsx","reportWebVitals.js","index.js"],"names":["drawRect","x","y","w","h","color","ctx","fillStyle","fillRect","drawCircle","radius","beginPath","arc","Math","PI","fill","CanvasWrapper","styled","div","WaveText","canvasWidth","canvasHeight","Canvas","gameState","canvasRef","React","useRef","useState","context","setContext","wave","setWave","wrapperRef","console","log","useEffect","current","renderCtx","getContext","incWave","ref","tabIndex","id","width","height","Sprite","startX","startY","angle","ttl","speed","this","random","Obj","damageColor","hp","originalColor","anchor","originalHp","hitTimeout","dmg","setTimeout","getDistance","myCol","myRow","targetCol","targetRow","abs","Enemy","target","direction","originalSpeed","limit","damage","prevGridUnit","currentGridUnit","findClosestTargetTimer","moveTimer","findClosestTarget","grid","col","row","currentTargetDistance","currentGridUnitPosition","players","forEach","player","isDead","getXY","incBlood","removeFromEnemiesGridPositions","enemy","level","floor","incPickup","move","hit","targetX","targetY","undefined","findGridUnit","targetsRow","targetsCol","xDir","yDir","gridCols","type","typeEnemy","addToEnemiesGridPositions","images","Player","name","shootingSpeedInterval","animationShootingSpeedInterval","rotateSpeedInterval","pickupInterval","bullets","collisionInterval","collisionPickupInterval","drive","reverse","steerLeft","steerRight","brake","isShooting","controlKeyGas","controlKeyRight","controlKeyReverse","controlKeyLeft","controlKeyShoot","sprites","shootingSprite","loadedImages","currentImage","animationSpeed","shouldDrawFireEffect","element","shoot","centerX","centerY","incProjectiles","drawFireEffect","save","translate","rotate","restore","keyDown","e","key","preventDefault","keySet","keyUp","map","src","image","Image","onload","barHeight","length","drawHealthBar","drawImage","addEventListener","removeEventListener","gas","right","left","setTo","die","animation","stayInsideMap","cos","sin","getPickups","p","collision","incLevel","getEnemies","enemy_1","enemy_2","gridRows","Array","colRowIndex","eachRowFirst","eachColFirst","index","background","insertSquares","drawMap","i","gridCellSize","createEnemy","Projectile","enemyGridCell","objA","objB","objAtop","objAbot","objAleft","objAright","objBtop","objBbot","objBleft","objBright","playerColors","bloodCanvas","document","createElement","GameState","enemies","enemyIndexToFindTarget","projectiles","pickups","blood","gameIsRunning","hasStartedGame","loop","enemiesGridPositions","enemyGroupToUpdate","update","getProjectiles","sprite","part","removeEnemies","removeProjectiles","removePickups","incEnemies","draw","drawStartScreen","firstRun","addPlayer","advance","turnRight","back","turnLeft","fire","playerHp","createNewPlayer","addKeyListeners","setUpControls","push","pause","window","clearInterval","setInterval","startGame","clearRect","reset","resurrect","enemyId","removeEventListeners","angleRadian","newProjectile","createProjectile","createPickup","filter","isAlive","numberOfEnemies","directions","maxRandDistance","getX","getY","MenuWrapper","MenuItem","InGameMenu","restart","quit","onClick","Wrapper","hasStarted","css","App","playersData","setPlayersData","nameValue","setNameValue","advanceControl","setAdvanceControl","turnRightControl","setTurnRightControl","turnLeftControl","setTurnLeftControl","moveBackwardsControl","setMoveBackwardsControl","fireControl","setFireControl","setHasStarted","showInGameMenu","setShowInGameMenu","showCanvas","setShowCanvas","handlePause","resetInputFields","resetGrid","disableAddPlayer","placeholder","value","onChange","onKeyDown","newPlayer","updatedPlayers","disabled","JSON","stringify","removePlayer","stopGame","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"iMAAaA,EAAW,SAACC,EAAWC,EAAWC,EAAWC,EAAWC,EAAgDC,GAC5GA,IACLA,EAAIC,UAAYF,EAChBC,EAAIE,SAASP,EAAGC,EAAGC,EAAGC,KAGbK,EAAa,SAACR,EAAWC,EAAWQ,EAAgBL,EAAgDC,GACxGA,IACLA,EAAIC,UAAYF,EAChBC,EAAIK,YACJL,EAAIM,IAAIX,EAAGC,EAAGQ,EAAQ,EAAa,EAAVG,KAAKC,IAC9BR,EAAIS,S,OCTKC,EAAgBC,IAAOC,IAAV,qLAUbC,EAAWF,IAAOC,IAAV,uH,OCLRE,EAAc,IACdC,EAAe,IACfC,EAA0B,SAAC,GAAoB,IAAlBC,EAAiB,EAAjBA,UAClCC,EAAYC,IAAMC,OAA0B,MADO,EAE3BD,IAAME,SAA0C,MAFrB,mBAElDC,EAFkD,KAEzCC,EAFyC,OAGjCF,mBAAS,GAHwB,mBAGlDG,EAHkD,KAG5CC,EAH4C,KAInDC,EAAaN,iBAAuB,MAsB1C,OArBAO,QAAQC,IAAI,iBAEZC,qBAAU,WACR,GAAIX,EAAUY,QAAS,CACrB,IAAMC,EAAYb,EAAUY,QAAQE,WAAW,MAC3CD,GAAad,IACfA,EAAUM,WAAWQ,GACrBd,EAAUgB,QAAU,SAACT,GAAD,OAAkBC,EAAQD,IAC9CD,EAAWQ,IAGTT,IAAO,OAAIL,QAAJ,IAAIA,OAAJ,EAAIA,EAAWjB,OACxBsB,EAAQrB,UAAY,OACpBqB,EAAQpB,SAAS,EAAG,GAAI,IAAK,KAC7BR,EAAS,IAAK,IAAK,IAAK,IAAK,MAAOuB,EAAUjB,SAIjD,CAACsB,EAASL,IAIX,eAACP,EAAD,CACEwB,IAAKR,EACLS,SAAU,EAFZ,UAKE,wBACEC,GAAG,SACHF,IAAKhB,EACLmB,MAAOvB,EACPwB,OAAQvB,IAEV,cAACF,EAAD,UAAWW,Q,4BC5CJe,EAAb,WAaE,WAAYC,EAAgBC,EAAgBC,GAAyE,IAA1DL,EAAyD,uDAAjD,EAAGC,EAA8C,uDAArC,EAAGvC,EAAkC,uDAA1B,QAAS4C,EAAiB,uDAAH,EAAG,yBAZpHP,QAYoH,OAXpHzC,OAWoH,OAVpHC,OAUoH,OATpH6C,YASoH,OARpHD,YAQoH,OAPpHH,WAOoH,OANpHC,YAMoH,OALpHM,WAKoH,OAJpHF,WAIoH,OAHpH3C,WAGoH,OAFpH4C,SAEoH,EAClHE,KAAKT,GAAK7B,KAAKuC,SACfD,KAAKlD,EAAI6C,EACTK,KAAKjD,EAAI6C,EACTI,KAAKL,OAASA,EACdK,KAAKJ,OAASA,EACdI,KAAKR,MAAQA,EACbQ,KAAKP,OAASA,EACdO,KAAKD,MAAQ,EACbC,KAAKH,MAAQA,EACbG,KAAK9C,MAAQA,EACb8C,KAAKF,IAAMA,EAxBf,0CA2BE,WACEE,KAAKF,QA5BT,qBA+BE,WACE,OAAOE,KAAKF,IAAM,IAhCtB,kBAmCE,WAAS,IACChD,EAA+BkD,KAA/BlD,EAAGC,EAA4BiD,KAA5BjD,EAAGyC,EAAyBQ,KAAzBR,MAAOC,EAAkBO,KAAlBP,OAAQvC,EAAU8C,KAAV9C,MAC7BL,EAASC,EAAGC,EAAGyC,EAAOC,EAAQvC,EAAOkB,EAAUe,gBArCnD,mBAwCE,WACEa,KAAKlD,EAAIkD,KAAKL,OACdK,KAAKjD,EAAIiD,KAAKJ,WA1ClB,KCEaM,EAAb,kDAQE,WAAapD,EAAWC,EAAWG,EAAeiD,EAAqBX,EAAeC,EAAgBM,EAAeK,GAAa,IAAD,8BAC/H,cAAMtD,EAAGC,EAAG,EAAGyC,EAAOC,EAAQvC,IARhCiD,iBAOiI,IANjIE,mBAMiI,IALjIC,YAKiI,IAJjIP,WAIiI,IAHjIK,QAGiI,IAFjIG,gBAEiI,IADjIC,gBACiI,EAE/H,EAAKL,YAAcA,EACnB,EAAKE,cAAgBnD,EACrB,EAAKoD,OAAS,CAACxD,EAAG,GAAKC,EAAG,IAC1B,EAAKgD,MAAQA,EACb,EAAKK,GAAKA,EACV,EAAKG,WAAaH,EAClB,EAAKI,WAAa,KAR6G,EARnI,uCAmBE,SAAKC,GAAc,IAAD,OACXT,KAAKQ,aAERR,KAAKI,IAAMK,EACXT,KAAK9C,MAAQ8C,KAAKG,YAClBH,KAAKQ,WAAaE,YAAW,WAC3B,EAAKxD,MAAQ,EAAKmD,cAClB,EAAKG,WAAa,OACjB,UA3BT,GAAyBd,GCLV,+fCAA,+cCeTiB,EAAc,SAACC,EAAeC,EAAeC,EAAmBC,GAMpE,OAHoBrD,KAAKsD,IAAIH,EAAQE,GACjBrD,KAAKsD,IAAIJ,EAAQE,IAK1BG,EAAb,kDAaE,WAAanE,EAAWC,EAAWG,EAAeiD,EAAqBX,EAAeC,EAAgBM,EAAeK,EAAYc,EAAa3B,GAAa,IAAD,8BACxJ,cAAMzC,EAAGC,EAAGG,EAAOiD,EAAaX,EAAOC,EAAQM,EAAOK,IAbxDb,QAY0J,IAX1J2B,YAW0J,IAV1JC,eAU0J,IAT1JC,mBAS0J,IAR1JC,WAQ0J,IAP1JjB,QAO0J,IAN1JN,SAM0J,IAL1JwB,YAK0J,IAJ1JC,kBAI0J,IAH1JC,qBAG0J,IAF1JC,4BAE0J,IAD1JC,eAC0J,IA4B1JC,kBAAoB,WAElB,GAAKC,EAAK,EAAKJ,iBAAf,CAGA,IAAMZ,EAAQgB,EAAK,EAAKJ,iBAAiBK,IACnChB,EAAQe,EAAK,EAAKJ,iBAAiBM,IAGnCC,EAAwBpB,EAC5BC,EACAC,EACAe,EAAK,EAAKV,OAAOc,yBAAyBH,IAC1CD,EAAK,EAAKV,OAAOc,yBAAyBF,KAG5C1D,EAAU6D,QAAQC,SAAQ,SAACC,IACRxB,EACfC,EACAC,EACAe,EAAKO,EAAOH,yBAAyBH,IACrCD,EAAKO,EAAOH,yBAAyBF,KAExBC,GAA0B,EAAKb,OAAOkB,SAAWD,EAAOC,UAErE,EAAKlB,OAASiB,QAnDlB,EAAKjB,OAASA,EACd,EAAK3B,GAAKA,EACV,EAAK4B,UAAY,GACjB,EAAKC,cAAgB5B,EACrB,EAAK6B,MAAQ,EACb,EAAKjB,GAAKZ,EAAQC,EAClB,EAAKK,IAAM,GACX,EAAKwB,OAAS,GACd,EAAKC,cAAgB,EACrB,EAAKC,iBAAmB,EACxB,EAAKC,uBArCyB,IAsC9B,EAAKC,UArCU,EAwByI,EAb5J,uCA6BE,SAAK7B,GAAgB,IAAD,EAElBG,KAAKF,IAAM,EAFO,MAGHuC,EAAMrC,KAAKwB,iBAAnB1E,EAHW,EAGXA,EAAGC,EAHQ,EAGRA,EACVqB,EAAUkE,SAASxF,EAAGC,EAAG8C,EAAOG,KAAKR,MAAOQ,KAAKP,QACjDrB,EAAUmE,+BAA+BvC,KAAKwB,gBAA9C,UAA+DI,EAAK5B,KAAKwB,iBAAiBgB,aAA1F,aAA+D,EAAkCjD,MAlCrG,qBAqCE,WACE,OAAOS,KAAKF,IAAM,IAtCtB,kBAyEE,WAGM1B,EAAU6D,QAAQ,GAAGQ,MAAQ,EAElB,IADA/E,KAAKgF,MAAsB,GAAhBhF,KAAKuC,WAE3B7B,EAAUuE,UAAU3C,KAAKlD,EAAGkD,KAAKjD,GAItB,IADAW,KAAKgF,MAAsB,IAAhBhF,KAAKuC,WAE3B7B,EAAUuE,UAAU3C,KAAKlD,EAAGkD,KAAKjD,KApFzC,oBA0FE,WACEiD,KAAK4C,OAED5C,KAAKwB,kBAAoBxB,KAAKkB,OAAOc,yBACvChC,KAAKkB,OAAO2B,IAAI,KA9FtB,kBAkGE,WAAQ,IAAD,EACL,GAAI7C,KAAK0B,UAAY,EACnB1B,KAAK0B,gBADP,CAWA,GAPA1B,KAAK0B,UAlHU,EAyHX1B,KAAKlD,EAAI,GAAKkD,KAAKlD,EAAIkD,KAAKR,MAAQpB,EAAUH,aAAe+B,KAAKjD,EAAI,GAAKiD,KAAKjD,EAAIiD,KAAKP,OAASrB,EAAUF,aAAc,CAE5H,IAAM4E,EAAUpF,KAAKgF,MAAM1C,KAAKkB,OAAOpE,GACjCiG,EAAUrF,KAAKgF,MAAM1C,KAAKkB,OAAOnE,GAkBvC,OAhBIiD,KAAKlD,GAAKgG,IACZ9C,KAAKmB,UAAY,QACjBnB,KAAKlD,GAAK,GAERkD,KAAKlD,GAAKgG,IACZ9C,KAAKmB,UAAY,OACjBnB,KAAKlD,GAAK,GAERkD,KAAKjD,GAAKgG,IACZ/C,KAAKmB,UAAY,OACjBnB,KAAKjD,GAAK,QAERiD,KAAKjD,GAAKgG,IACZ/C,KAAKmB,UAAY,KACjBnB,KAAKjD,GAAK,IAId,GAAIiD,KAAKqB,MAAQ,EACfrB,KAAKqB,YADP,CAIArB,KAAKqB,MAAQ,GAIgB,OAAzBrB,KAAKwB,sBAAqDwB,IAAzBhD,KAAKwB,iBAAiCxB,KAAKwB,gBAAkB,KAChGxB,KAAKwB,gBAAkByB,EAAajD,KAAKlD,EAAGkD,KAAKjD,IAGnDiD,KAAKuB,aAAL,UAAoBvB,KAAKwB,uBAAzB,QAA4CyB,EAAajD,KAAKlD,EAAIkD,KAAKR,MAAM,EAAGQ,KAAKjD,EAAIiD,KAAKP,OAAO,GAErG,IAAMyD,EAAatB,EAAK5B,KAAKkB,OAAOc,yBAAyBF,IACvDqB,EAAavB,EAAK5B,KAAKkB,OAAOc,yBAAyBH,IAlDxD,EAoDgBD,EAAK5B,KAAKwB,iBAAvBK,EApDH,EAoDGA,IAAKC,EApDR,EAoDQA,IACTsB,EAAO,GACPC,EAAO,GACXrD,KAAKmB,UAAY,GACb+B,EAAapB,IACfuB,EAAO,MAELH,EAAapB,IACfuB,EAAO,QAELF,EAAatB,IACfuB,EAAO,QAELD,EAAatB,IACfuB,EAAO,SAIT,IAAMnD,EAASvC,KAAKuC,SAUpB,OARED,KAAKmB,UADHlB,EAAS,IAAOA,EAAS,GACV,GACRA,GAAU,GACFmD,EAEAC,EAIXrD,KAAKmB,WACX,IAAK,KAAO,IAAD,EACLS,EAAK5B,KAAKwB,gBAAkB8B,KAAa,UAAA1B,EAAK5B,KAAKwB,gBAAkB8B,UAA5B,eAAuCC,QAASC,IAC3FxD,KAAKwB,iBAAmB8B,GAE1B,MAEF,IAAK,OAAS,IAAD,EACP1B,EAAK5B,KAAKwB,gBAAkB8B,KAAa,UAAA1B,EAAK5B,KAAKwB,gBAAkB8B,UAA5B,eAAuCC,QAASC,IAC3FxD,KAAKwB,iBAAmB8B,GAE1B,MAEF,IAAK,OAAS,IAAD,EACP1B,EAAK5B,KAAKwB,gBAAiB,KAAM,UAAAI,EAAK5B,KAAKwB,gBAAiB,UAA3B,eAA+B+B,QAASC,IAC3ExD,KAAKwB,iBAAmB,GAE1B,MAEF,IAAK,QAAU,IAAD,EACRI,EAAK5B,KAAKwB,gBAAkB,KAAM,UAAAI,EAAK5B,KAAKwB,gBAAkB,UAA5B,eAAgC+B,QAASC,IAC7ExD,KAAKwB,iBAAmB,GAO1BxB,KAAKwB,kBAAoBxB,KAAKuB,eAChCnD,EAAUqF,0BAA0BzD,KAAKwB,gBAAiBxB,MAC1D5B,EAAUmE,+BAA+BvC,KAAKuB,aAAcvB,KAAKT,WAhNvE,GAA2BW,GCdrBwD,EAAS,CCVA,y2BCAA,q2BCAA,y7BCAA,y9BCAA,sqCLsBFC,EAAb,kDA8BE,WAAaC,EAAc9G,EAAWC,EAAWG,EAAeiD,EAAqBX,EAAeC,EAAgBM,EAAeK,GAAa,IAAD,8BAC7I,cAAMtD,EAAGC,EAAGG,EAAOiD,EAAaX,EAAOC,EAAQM,EAAOK,IA9BxDyD,2BA6B+I,IA5B/IC,oCA4B+I,IA3B/IC,yBA2B+I,IA1B/IC,oBA0B+I,IAzB/IC,aAyB+I,IAxB/IC,uBAwB+I,IAvB/IC,6BAuB+I,IAtB/I1B,WAsB+I,IArB/I2B,WAqB+I,IApB/IC,aAoB+I,IAnB/IC,eAmB+I,IAlB/IC,gBAkB+I,IAjB/IC,WAiB+I,IAhB/IC,gBAgB+I,IAf/IC,mBAe+I,IAd/IC,qBAc+I,IAb/IC,uBAa+I,IAZ/IC,oBAY+I,IAX/IC,qBAW+I,IAV/I9C,6BAU+I,IAT/I4B,UAS+I,IAR/ImB,aAQ+I,IAP/IC,oBAO+I,IAN/IC,kBAM+I,IAL/IC,kBAK+I,IAJ/IC,oBAI+I,IAH/I/C,YAG+I,IAF/IgD,0BAE+I,IAD/IC,aAC+I,IA6D/IC,MAAQ,WAON,GANI,EAAKrB,SAAW,GAClBvD,YAAW,WACT,EAAKuD,QAnGF,GAmGmB,EAAKxB,MAAQ,IAClC,MAGD,EAAKoB,uBACH,EAAKI,QAAU,EAAG,CACpB,IAAMsB,EAAU,EAAKzI,EAAI,EAAK0C,MAAQ,EAChCgG,EAAU,EAAKzI,EAAI,EAAK0C,OAAS,EAEvCrB,EAAUqH,eAAeF,EAASC,GAAU,EAAK3F,MAAwB,GAAhBnC,KAAKuC,UAAiBvC,KAAKC,GAAK,KACzFS,EAAUqH,eAAeF,EAASC,GAAU,EAAK3F,MAAwB,GAAhBnC,KAAKuC,UAAgBvC,KAAKC,GAAK,KACxFS,EAAUqH,eAAeF,EAASC,EAAS,EAAK3F,MAAQnC,KAAKC,GAAK,KAClES,EAAUqH,eAAeF,EAASC,GAAU,EAAK3F,MAAwB,GAAhBnC,KAAKuC,UAAiBvC,KAAKC,GAAK,KACzFS,EAAUqH,eAAeF,EAASC,GAAU,EAAK3F,MAAwB,GAAhBnC,KAAKuC,UAAiBvC,KAAKC,GAAK,KAEzF,EAAKsG,SAAW,EAChB,EAAKmB,sBAAuB,EAC5B,EAAKvB,sBAAwBnD,YAAW,WACtC,EAAKmD,sBAAwB,OAC5B,OAnFsI,EAkJ/I6B,eAAiB,WACf,EAAKN,sBAAuB,EAC5B,IAAMjI,EAAMiB,EAAUe,aACtB,GAAKhC,EAAL,CACA,IAAMoI,EAAU,EAAKzI,EAAI,EAAK0C,MAAQ,EAChCgG,EAAU,EAAKzI,EAAI,EAAK0C,OAAS,EACjCI,EAAQ,EAAKA,MAAQnC,KAAKC,GAAK,IACrCR,EAAIwI,OACJxI,EAAIyI,UAAUL,EAASC,GACvBrI,EAAI0I,OAAOhG,GACX1C,EAAIyI,WAAWL,GAAUC,GAEzBrI,EAAIC,UAAY,UAChBD,EAAIE,SAASkI,EAAU,EAAGC,EAAS,EAAG,GACtCrI,EAAI2I,YAhKyI,EAwM/IC,QAAU,SAACC,GACK,WAAVA,EAAEC,MACND,EAAEE,iBACF,EAAKC,OAAOH,GAAG,KA3M8H,EA8M/II,MAAQ,SAACJ,GACPA,EAAEE,iBACF,EAAKC,OAAOH,GAAG,IA9Mf,EAAKnC,sBAAwB,KAC7B,EAAKC,+BAAiC,EACtC,EAAKC,oBAAsB,KAC3B,EAAKC,eAAiB,KACtB,EAAKC,QAzCE,GA0CP,EAAKC,kBAAoB,KACzB,EAAKC,wBAA0B,KAC/B,EAAK1B,MAAQ,EACb,EAAKmB,KAAOA,EACZ,EAAKQ,OAAQ,EACb,EAAKC,SAAU,EACf,EAAKC,WAAY,EACjB,EAAKC,YAAa,EAClB,EAAKC,OAAQ,EACb,EAAKC,YAAa,EAElB,EAAKC,mBAAgB1B,EACrB,EAAK2B,qBAAkB3B,EACvB,EAAK4B,uBAAoB5B,EACzB,EAAK6B,oBAAiB7B,EACtB,EAAK8B,qBAAkB9B,EAEvB,EAAKhB,wBAA0B,EAC/B,EAAK+C,QAAUrB,EAAO2C,KAAI,SAACC,GACzB,IAAMC,EAAQ,IAAIC,MAAMhH,EAAOC,GAM/B,OALA8G,EAAMD,IAAMA,EACZC,EAAME,OAAS,WACb3H,QAAQC,IAAI,SAAUuH,GACtB,EAAKrB,gBAEAsB,KAET,EAAKvB,eAAiB,IAAIwB,MAAMhH,EAAOC,GACvC,EAAKwF,aAAe,EACpB,EAAKC,aAAe,EACpB,EAAKC,eAAiB,GACtB,EAAK/C,QAAS,EACd,EAAKgD,sBAAuB,EAvCiH,EA9BjJ,iDAwEE,WACMpF,KAAKlD,GAAK,IAAGkD,KAAKlD,EAAI,GACtBkD,KAAKlD,EAAIkD,KAAKR,OAASpB,EAAUH,cACnC+B,KAAKlD,EAAIsB,EAAUH,YAAc+B,KAAKR,OAEpCQ,KAAKjD,GAAK,IAAGiD,KAAKjD,EAAI,GACtBiD,KAAKjD,EAAKiD,KAAKP,OAAS,GAAMrB,EAAUF,eAC1C8B,KAAKjD,EAAIqB,EAAUF,aAAe8B,KAAKP,UA/E7C,sBAmFE,WAAa,IAAD,OACNO,KAAKmE,0BACTnE,KAAKmE,wBAA0BzD,YAAW,WACxC,EAAKyD,wBAA0B,OAC9B,KACHnE,KAAKyC,WAxFT,2BAyIE,SAAetF,GAAgC,IACrCqC,EAAkBQ,KAAlBR,MAAOC,EAAWO,KAAXP,OACf,GAAIO,KAAK9C,QAAU8C,KAAKG,YAAa,CACnC,IAAMuG,GAAajH,EACnBtC,EAAIC,UAAY,UAChBD,EAAIE,UAAUmC,EAAQ,EAAGkH,EAAWlH,EAAO,GAC3CrC,EAAIC,UAAY,UAChBD,EAAIE,UAAUmC,EAAQ,EAAGkH,EAAWlH,GAASQ,KAAKI,GAAKJ,KAAKO,YAAa,MAhJ/E,kBAoJE,WAAS,IAECzD,EAAwBkD,KAAxBlD,EAAGC,EAAqBiD,KAArBjD,EAAGyC,EAAkBQ,KAAlBR,MAAOC,EAAWO,KAAXP,OACftC,EAAMiB,EAAUe,cACjBhC,GAAO6C,KAAKiF,aAAevB,EAAOiD,OAAQ,IAC/CxJ,EAAIwI,OACJxI,EAAIyI,UAAU9I,EAAI0C,EAAQ,EAAGzC,EAAI0C,EAAS,GAEtCO,KAAKI,GAAK,GACZJ,KAAK4G,cAAczJ,GAErBA,EAAI0I,QAAQ7F,KAAKH,MAAQ,IAAMnC,KAAKC,GAAK,KAEzCR,EAAI0J,UACF7G,KAAK+E,QAAQ/E,KAAKkF,cAClBxH,KAAKgF,OAAOlD,EAAQ,GACpB9B,KAAKgF,OAAOjD,EAAS,GACrBD,EACAC,GAIFtC,EAAI2I,UAEA9F,KAAKoF,sBACPpF,KAAK0F,oBA7KX,6BAiME,SAAiBL,GACfrF,KAAKqF,QAAUA,EACfA,EAAQyB,iBAAiB,UAAW9G,KAAK+F,SACzCV,EAAQyB,iBAAiB,QAAS9G,KAAKoG,SApM3C,kCAuME,WACEpG,KAAKqF,QAAQ0B,oBAAoB,UAAW/G,KAAK+F,SACjD/F,KAAKqF,QAAQ0B,oBAAoB,QAAS/G,KAAKoG,SAzMnD,2BA4ME,SAAeY,EAAUC,EAAY5C,EAAc6C,EAAW5B,GAC5DtF,KAAK0E,cAAgBsC,EACrBhH,KAAK2E,gBAAkBsC,EACvBjH,KAAK4E,kBAAoBP,EACzBrE,KAAK6E,eAAiBqC,EACtBlH,KAAK8E,gBAAkBQ,IAjN3B,oBAoNE,SAAQU,EAAiBmB,GACnBnB,EAAEC,MAAQjG,KAAK0E,gBACjB1E,KAAKoE,MAAQ+C,GAEXnB,EAAEC,MAAQjG,KAAK2E,kBACjB3E,KAAKuE,WAAa4C,GAEhBnB,EAAEC,MAAQjG,KAAK4E,oBACjB5E,KAAKqE,QAAU8C,GAEbnB,EAAEC,MAAQjG,KAAK6E,iBACjB7E,KAAKsE,UAAY6C,GAEfnB,EAAEC,MAAQjG,KAAK8E,kBACjB9E,KAAKyE,WAAa0C,KAlOxB,oBAiPE,YACOnH,KAAKoC,QAAUpC,KAAKI,IAAM,GAC7BJ,KAAKoH,MAEPpH,KAAK4C,SArPT,uBAwPE,WACE5C,KAAKmF,iBACDnF,KAAKmF,gBAAkB,IAGvBnF,KAAKmF,eAAiB,IACxBnF,KAAKmF,eAAiB,GAGpBnF,KAAKoE,OAMEpE,KAAKqE,QALY,IAAtBrE,KAAKkF,aACPlF,KAAKkF,aAAe,EAEpBlF,KAAKkF,aAAe,EAQblF,KAAK6D,sBACd7D,KAAKkF,aAAe,EAGpBlF,KAAKkF,aAAe,KAjR1B,kBAsRE,WACE,IAAIlF,KAAKoC,UACLpC,KAAKF,KAAO,GAAhB,CAEAE,KAAKqH,YACDrH,KAAKoE,MACPpE,KAAKD,MAAQ,EAEbC,KAAKD,MAAQ,EAGXC,KAAKyE,YACPzE,KAAKsF,QAGHtF,KAAKqE,UACPrE,KAAKD,OAAS,IAGZC,KAAKsE,YACPtE,KAAKH,OAAS,GAIZG,KAAKuE,aACPvE,KAAKH,OAAS,GAGZG,KAAKH,MAAQ,MACfG,KAAKH,MAAQ,GAEVG,KAAKH,MAAQ,IAChBG,KAAKH,MAAQ,KAIfG,KAAKsH,gBAGLtH,KAAKlD,GAAKY,KAAK6J,IAAIvH,KAAKH,MAAQnC,KAAKC,GAAK,KAAOqC,KAAKD,MACtDC,KAAKjD,GAAKW,KAAK8J,IAAIxH,KAAKH,MAAQnC,KAAKC,GAAK,KAAOqC,KAAKD,MAKtD,IAAMyB,EAAkByB,EAAajD,KAAKlD,EAAIkD,KAAKR,MAAM,EAAGQ,KAAKjD,EAAIiD,KAAKP,OAAO,GAC7EmC,EAAKJ,KACPxB,KAAKgC,wBAA0BR,MArUrC,kCA0UE,WAAyB,IAAD,OAENpD,EAAUqJ,aAClBvF,SAAQ,SAACwF,GACXC,EAAU,EAAMD,KAClBA,EAAE5H,IAAM,EACJ,EAAK2C,MAAQ,EACf,EAAKmF,WAELxJ,EAAUyJ,aAAa3F,SAAQ,SAACpF,GAC9BA,EAAEsK,eApVd,iBA4VE,WACEtI,QAAQC,IAAI,OACZiB,KAAKoC,QAAS,EACdpC,KAAKkF,aAAe,EACpB9G,EAAUkE,SAAStC,KAAKlD,EAAGkD,KAAKjD,EAAG,EAAG,GAAI,MAhW9C,uBAmWE,WACEiD,KAAKoC,QAAS,EACdpC,KAAKI,GAAKJ,KAAKO,eArWnB,GAA4BL,GMftBwD,EAAS,CACboE,EACAC,GAYWzE,EAAW5F,KAAKgF,MAAMzE,KACtB+J,EAAWtK,KAAKgF,MAAMxE,KACxB0D,EASL,IAAIqG,MAAM3E,EAAW0E,GAEdxE,EAAY,QAILE,EAAO2C,KAAI,SAACC,GAC9B,IAAMC,EAAQ,IAAIC,MAnBQ,KAyB1B,OALAD,EAAMD,IAAMA,EACZC,EAAME,OAAS,WACb3H,QAAQC,IAAI,SAAUuH,IAGjBC,KAoBF,SAAS2B,EAAarG,EAAaC,GACxC,OAAOD,EAAMyB,EAAWxB,GAnB1B,WACE,IAAK,IAAIqG,EAAe,EAAGA,EAAeH,EAAUG,IAClD,IAAK,IAAIC,EAAe,EAAGA,EAAe9E,EAAU8E,IAAgB,CAClE,IAAMC,EAAQH,EAAYE,EAAcD,GACxCvG,EAAKyG,GAAS,CACZ9E,KAAM,GACN+E,WAAY,GACZzG,IAAKuG,EACLtG,IAAKqG,EACLrL,EApCoB,EAoCjBsL,EACHrL,EArCoB,EAqCjBoL,IAMXI,GAMO,IAAMlG,EAAQ,SAACgG,GAIpB,MAAO,CACLvL,EAJSuL,EAAQ/E,EAlDO,EAuDxBvG,EAvDwB,EAmDhBW,KAAKgF,MAAO2F,EAAQ/E,KAQzB,SAASL,EAAcsC,EAAiBC,GAG7C,OAAO0C,EAFSxK,KAAKgF,MAAM6C,EA5DD,GA6DV7H,KAAKgF,MAAM8C,EA7DD,IAiErB,SAASgD,EAAQrL,GAGtB,IAAK,IAAIsL,EAAI,EAAGA,EAAI7G,EAAK+E,OAAQ8B,IAAK,CAAC,IAAD,EACQ7G,EAAK6G,GAAzClF,EAD4B,EAC5BA,KAA2BzG,GADC,EACtBwL,WADsB,EACVzG,IADU,EACLC,IADK,EACDhF,GAAGC,EADF,EACEA,EAEtC,GAAIwG,IAASC,EAAW,CAEtBlG,EAAWR,EAAGC,EATL2L,IAQK,UACkBvL,KAe/B,IAsBMwL,EACX,SAAC7L,EAAWC,EAAWyC,EAAeC,EAAgByB,GAAtD,OACE,IAAID,EACFnE,EACAC,EACA,OACA,QACAyC,EACAC,EACA/B,KAAKgF,MAAsB,GAAhBhF,KAAKuC,UAAiB,EACjCT,EAAQ,EACR0B,EACAxD,KAAKuC,WCzIE2I,EAAb,kDAGE,WAAYjJ,EAAgBC,EAAgBC,GAAgB,IAAD,8BACzD,cAAMF,EAAQC,EAAQC,EAAO,EAAG,EAAG,YAHrC0B,kBAE2D,IAD3DC,qBAC2D,EAEzD,EAAKzB,MAAQ,GACb,EAAKD,IAAM,GACX,EAAK0B,gBAAkByB,EAAa,EAAKnG,EAAI,EAAK0C,MAAM,EAAG,EAAKzC,EAAI,EAAKyC,MAAM,GAC/E,EAAK+B,aAAe,EAAKC,gBALgC,EAH7D,2CAWE,WACE,OAAOxB,KAAKF,IAAM,IAZtB,kBAeE,WAAS,IAAD,EAON,GANAE,KAAKlD,GAAKY,KAAK6J,IAAIvH,KAAKH,OAASG,KAAKD,MACtCC,KAAKjD,GAAKW,KAAK8J,IAAIxH,KAAKH,OAASG,KAAKD,MAKlCC,KAAKlD,EAAI,GAAKkD,KAAKlD,EAAIsB,EAAUH,aAAe+B,KAAKjD,EAAI,GAAKiD,KAAKjD,EAAIqB,EAAUF,aACnF8B,KAAKF,IAAM,OAOb,GAFAE,KAAKuB,aAAL,UAAoBvB,KAAKwB,uBAAzB,QAA4CyB,EAAajD,KAAKlD,EAAIkD,KAAKR,MAAM,EAAGQ,KAAKjD,EAAIiD,KAAKR,MAAM,GACpGQ,KAAKwB,gBAAkByB,EAAajD,KAAKlD,EAAIkD,KAAKR,MAAM,EAAGQ,KAAKjD,EAAIiD,KAAKR,MAAM,QAC5CwD,IAA/BpB,EAAK5B,KAAKwB,iBAAd,CACA,IACgD,MAUvB,EAXrBqH,GAAiB,EACrB,GAAI7I,KAAKuB,eAAiBvB,KAAKwB,gBAU7B,GATII,EAAK5B,KAAKwB,iBAAiB+B,OAASC,EACtCqF,EAAgB7I,KAAKwB,iBACZ,UAAAI,EAAK5B,KAAKwB,gBAAkB8B,UAA5B,eAAuCC,QAASC,EACzDqF,EAAgB7I,KAAKwB,gBAAkB8B,GAC9B,UAAA1B,EAAK5B,KAAKwB,gBAAiB,UAA3B,eAA+B+B,QAASC,EACjDqF,EAAgB7I,KAAKwB,gBAAkB,GAC9B,UAAAI,EAAK5B,KAAKwB,gBAAiB,UAA3B,eAA+B+B,QAASC,IACjDqF,EAAgB7I,KAAKwB,gBAAkB,GAErCqH,EAAgB,EAClB,UAAAjH,EAAKiH,GAAerG,aAApB,SAA2B4E,IAAIpH,KAAKH,OACpCG,KAAKF,IAAM,KA5CnB,oBAkDE,WACEE,KAAK4C,SAnDT,kBAsDE,WAAS,IACC9F,EAAgBkD,KAAhBlD,EAAGC,EAAaiD,KAAbjD,EAAGyC,EAAUQ,KAAVR,MACdlC,EAAWR,EAAGC,EAAGyC,EAAOQ,KAAK9C,MAAOkB,EAAUe,kBAxDlD,GAAgCO,GCGnBiI,EAAY,SAACmB,EAAWC,GACnC,IAAMC,EAAUF,EAAK/L,EAAI+L,EAAKrJ,OACxBwJ,EAAUH,EAAK/L,EAAI+L,EAAKrJ,OACxByJ,EAAWJ,EAAKhM,EAAIgM,EAAKtJ,MACzB2J,EAAYL,EAAKhM,EAAIgM,EAAKtJ,MAE1B4J,EAAUL,EAAKhM,EAAIgM,EAAKtJ,OACxB4J,EAAUN,EAAKhM,EAAIgM,EAAKtJ,OACxB6J,EAAWP,EAAKjM,EAAIiM,EAAKvJ,MACzB+J,EAAYR,EAAKjM,EAAIiM,EAAKvJ,MAQhC,OALmBwJ,GAAWK,GACzBJ,GAAWG,IACGF,GAAYK,GAC1BJ,GAAaG,ICjBpB,I,QCeWlL,EDfLoL,EAAe,CACnB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WAEIC,EAAiCC,SAASC,cAAc,UAEjDC,EAAb,WAoBE,aAAgB,IAAD,gCAnBfnH,WAmBe,OAlBfoH,aAkBe,OAjBfC,4BAiBe,OAhBfC,iBAgBe,OAffC,aAee,OAdf/H,aAce,OAbfgI,WAae,OAZfC,mBAYe,OAXfC,oBAWe,OAVfC,UAUe,OATfC,0BASe,OAPfpM,iBAOe,OANfC,kBAMe,OAJff,SAIe,OAHfiC,aAGe,OAFfkL,wBAEe,OAsBf5L,WAAa,SAACvB,GACZ,EAAKA,IAAMA,GAvBE,KA0BfgC,WAAa,WACX,OAAO,EAAKhC,KA3BC,KAwDfoN,OAAS,WAEP,EAAKtI,QAAQC,SAAQ,SAACpF,GAAD,OAAOA,EAAEyN,YAC9B,EAAKC,iBAAiBtI,SAAQ,SAAAuI,GAAM,OAAIA,EAAOF,YAG/C,IAAMG,EAAOhN,KAAKgF,MAAM,EAAKmH,QAAQlD,OAAS,GAC9C,OAAQ,EAAK2D,oBACX,KAAK,EACH,IAAK,IAAI7B,EAAI,EAAGA,EAAIiC,EAAMjC,IACxB,EAAKoB,QAAQpB,GAAG8B,SAElB,EAAKD,mBAAqB,EAC1B,MAEF,KAAK,EACH,IAAK,IAAI7B,EAAIiC,EAAMjC,EAAI,EAAKoB,QAAQlD,OAAQ8B,IAC1C,EAAKoB,QAAQpB,GAAG8B,SAElB,EAAKD,mBAAqB,EAC1B,MAEF,KAAK,EACH,IAAK,IAAI7B,EAAIiC,EAAO,EAAKJ,mBAAoB7B,EAAI,EAAKoB,QAAQlD,OAAQ8B,IACpE,EAAKoB,QAAQpB,GAAG8B,SAElB,EAAKD,mBAAqB,EAC1B,MAEF,KAAK,EACH,IAAK,IAAI7B,EAAIiC,EAAO,EAAKJ,mBAAoB7B,EAAI,EAAKoB,QAAQlD,OAAQ8B,IACpE,EAAKoB,QAAQpB,GAAG8B,SAElB,EAAKD,mBAAqB,EAM9B,EAAKL,MAAM/H,SAAQ,SAAAuI,GAAM,OAAIA,EAAOF,YACpC,EAAKI,gBACL,EAAKC,oBACL,EAAKC,gBACD,EAAKhB,QAAQ,EAAKC,yBACpB,EAAKD,QAAQ,EAAKC,wBAAwBnI,oBAE5C,EAAKmI,yBACD,EAAKA,uBAAyB,EAAKD,QAAQlD,SAC7C,EAAKmD,wBAA0B,KAE7B,EAAKD,QAAQlD,QAAU,IAEzB,EAAKiB,WACL,EAAKkD,eA7GM,KAiHfC,KAAO,WAAO,IAAD,EACN,EAAKb,eAMVrN,EAAS,EAAG,EAAG,EAAKoB,YAAa,EAAKC,aAAc,UAAW,EAAKf,KACpE,YAAKA,WAAL,SAAU0J,UAAU4C,EAAY,EAAE,EAAE,EAAKxL,YAAa,EAAKC,cAI3DsK,EAAQ,EAAKrL,KACb,EAAKqN,iBAAiBtI,SAAQ,SAAAuI,GAAM,OAAIA,EAAOM,UAE/C,EAAK9I,QAAQC,SAAQ,SAACpF,GAAD,OAAOA,EAAEiO,WAX5BjM,QAAQC,IAAI,6BArHD,KAoIfiM,gBAAkB,SAACC,GACZ,EAAK9N,MACVN,EAAS,EAAG,EAAG,EAAKoB,YAAa,EAAKC,aAAc,OAAQ,EAAKf,KACjEqL,EAAQ,EAAKrL,OAvIA,KA0If+N,UAAY,SAAEtH,EAAcuH,EAAiBC,EAAmBC,EAAcC,EAAkBC,EAAcC,EAAkBnG,GAC9H,IAAMnI,EAAQsM,EAAa,EAAKvH,QAAQ0E,QAClCxE,EHxEqB,SAC7ByB,GAD6B,OAU1B,IAAID,EACPC,EAX6B,uDAEzB,EAFyB,uDAGzB,EAHyB,uDAIrB,OAJqB,uDAKlB,QALkB,uDAMrB8E,GANqB,uDAOpBA,GAPoB,uDAQrB,EARqB,uDASxB,IG+DY+C,CACb7H,EACA,EAAK3F,YAAc,EAAI,GAAK,EAAKgE,QAAQ0E,OACzC,EAAKzI,aAAe,EACpBhB,EACA,WACA8F,OACAA,OACAA,EACAwI,GACFrJ,EAAOuJ,gBAAgBrG,GACvBlD,EAAOwJ,cAAcR,EAASC,EAAWC,EAAMC,EAAUC,GACzD,EAAKtJ,QAAQ2J,KAAKzJ,IAxJL,KA2Jf0J,MAAQ,WACF,EAAKzB,MACP0B,OAAOC,cAAc,EAAK3B,MAC1B,EAAKA,KAAO,KACZ,EAAKF,eAAgB,IAErB,EAAKA,eAAgB,EACrB,EAAKE,KAAO4B,aAAY,WACtB,EAAKzB,SACL,EAAKQ,SACJ,MArKQ,KA0KfkB,UAAY,WAAO,IAAD,EAChBnN,QAAQC,IAAI,UACZ,EAAK8K,QAAU,GACf,EAAKE,YAAc,GACnB,EAAKE,MAAQ,GACb,UAAAR,EAAYtK,WAAW,aAAvB,SAA8B+M,UAAU,EAAG,EAAGjO,EAAaC,GAC3D,EAAK+D,QAAQC,SAAQ,SAACpF,GACpBA,EAAEqP,QACFrP,EAAEsP,eAGJ,EAAKlC,eAAgB,EACrB,EAAKY,aACD,EAAKV,MACP0B,OAAOC,cAAc,EAAK3B,MAG5B,EAAKA,KAAO4B,aAAY,WACtB,EAAKzB,SACL,EAAKQ,SACJ,KA7LH/K,KAAKyC,MAAQ,EACbzC,KAAK6J,QAAU,GACf7J,KAAK8J,uBAAyB,EAC9B9J,KAAK+J,YAAc,GACnB/J,KAAKgK,QAAU,GACfhK,KAAKiC,QAAU,GACfjC,KAAKiK,MAAQ,GACbjK,KAAKkK,eAAgB,EACrBlK,KAAKmK,gBAAiB,EACtBnK,KAAKoK,KAAO,KACZpK,KAAKqK,qBAAuB,GAE5BrK,KAAK/B,YAAcA,EACnB+B,KAAK9B,aAAeA,EACpBuL,EAAYjK,MAAQvB,EACpBwL,EAAYhK,OAASvB,EACrB8B,KAAKsK,mBAAqB,EAE1BtK,KAAKZ,QAAU,aAvCnB,gEAkDE,WACEY,KAAKqK,qBAAuB,IAAIpC,MAAMrG,EAAK+E,QAE3C,IADA,IAAMA,EAAS3G,KAAKqK,qBAAqB1D,OAChC8B,EAAI,EAAGA,GAAK9B,EAAQ,EAAG8B,QArDpC,uCA2DE,SAA2BJ,EAAe7F,GACpC6F,GAAS,GAAKA,EAAQzG,EAAK+E,SAC7B/E,EAAKyG,GAAO9E,KAAOC,EACnB5B,EAAKyG,GAAO7F,MAAQA,KA9D1B,4CAkEE,SAAgC6F,EAAegE,GAAe,IAAD,OACvCrJ,IAAhBpB,EAAKyG,IAAsBvJ,QAAQC,IAAI,wBACvBiE,IAAhBpB,EAAKyG,IACLzG,EAAKyG,GAAO9E,OAASC,IAAa,UAAA5B,EAAKyG,GAAO7F,aAAZ,eAAmBjD,MAAO8M,IAC9DzK,EAAKyG,GAAO9E,KAAO,GACnB3B,EAAKyG,GAAO7F,WAAQQ,KAvE1B,sBAqNE,WACEhD,KAAKkK,eAAgB,EACrBlK,KAAKiC,QAAQC,SAAQ,SAACpF,GACpBA,EAAEwP,0BAEJP,cAAc/L,KAAKoK,MACnBpK,KAAKgL,oBA3NT,4BA8NE,SAAgBlO,EAAWC,EAAWwP,GAEpC,IACMC,EDxNH,SAA2B1P,EAAWC,EAAW8C,GAEtD,OADmB,IAAI+I,EAAW9L,EAAGC,EAAG8C,GCuNhB4M,CAAiB3P,EAAGC,EADxBwP,GAElBvM,KAAK+J,YAAY6B,KAAKY,KAlO1B,uBAqOE,SAAW1P,EAAWC,GACpBiD,KAAKgK,QAAQ4B,KDjKV,SAAuB9O,EAAWC,EAAW8C,GAElD,OADe,IAAIH,EAAO5C,EAAGC,EAAG8C,EAD0D,uDAAjB,GAAiB,uDAAJ,GAChC,UCgKlC6M,CAAa5P,EAAGC,EAAG,MAtOzC,wBAyOE,WACE,OAAOiD,KAAKgK,UA1OhB,2BA6OE,cA7OF,+BAkPE,WACEhK,KAAK+J,YAAc/J,KAAK+J,YAAY4C,QAAO,SAAA7P,GAAC,OAAIA,EAAE8P,eAnPtD,wBAsPE,WAqCE,IArCa,IAAD,OAINC,EAAkB,IAAM7M,KAAKyC,MAAQzC,KAAKiC,QAAQ0E,OAClDmG,EAAa,CAAC,MAAO,QAAS,MAAO,QAErCC,EAAkB,IAClBC,EAAO,SAAC7L,GAEZ,IAAIrE,EAAI,EAQR,MAPkB,QAAdqE,GAAqC,QAAdA,EACzBrE,EAAIY,KAAKuC,SAAW,EAAKhC,YACF,SAAdkD,EACTrE,GAAoB,IAAhBY,KAAKuC,SARS,EASK,UAAdkB,IACTrE,EAAI,EAAKmB,YAAeP,KAAKuC,SAAW8M,EAVtB,GAYbrP,KAAKgF,MAAM5F,IAGdmQ,EAAO,SAAC9L,GAEZ,IAAIpE,EAAI,EAQR,MAPkB,SAAdoE,GAAsC,UAAdA,EAC1BpE,EAAIW,KAAKuC,SAAW,EAAK/B,aACF,QAAdiD,EACTpE,GAAoB,IAAhBW,KAAKuC,SArBS,EAsBK,QAAdkB,IACTpE,EAAI,EAAKmB,aAAgBR,KAAKuC,SAAW8M,EAvBvB,GAyBbrP,KAAKgF,MAAM3F,IAGdkD,EAASvC,KAAKgF,MAAMhF,KAAKuC,SAAWD,KAAKiC,QAAQ0E,QACjDzF,EAASlB,KAAKiC,QAAQhC,GAEnBwI,EAAI,EAAGA,EAAIoE,EAAiBpE,IAAK,CACxC,IAAMtH,EAAY2L,EAAWpP,KAAKgF,MAAsB,EAAhBhF,KAAKuC,WACvCnD,EAAIkQ,EAAK7L,GACTpE,EAAIkQ,EAAK9L,GACfnB,KAAK6J,QAAQ+B,KAAKjD,EAAY7L,EAAGC,EH/RX,IG+R0CmE,OA/RtE,sBAqSE,SAAUpE,EAAWC,EAAW8C,EAAeL,EAAeC,GAC1C/B,KAAKgF,MAAsB,EAAhBhF,KAAKuC,UAChBvC,KAAKgF,MAAsB,EAAhBhF,KAAKuC,UADlC,IAGM9C,EAAMsM,EAAYtK,WAAW,MAC9BhC,GACLG,EAAWR,EAAGC,EAAGyC,EAAO,UAAWrC,KA3SvC,sBA+UE,WACE,OAAO6C,KAAKiK,QAhVhB,2BAmVE,WACEjK,KAAK6J,QAAU7J,KAAK6J,QAAQ8C,QAAO,SAAA7P,GAAC,OAAIA,EAAE8P,eApV9C,sBAuVE,WACE,OAAO5M,KAAKyC,QAxVhB,sBA2VE,WACE3D,QAAQC,IAAI,aACZiB,KAAKyC,QACLzC,KAAKZ,QAAQY,KAAKyC,OAClBzC,KAAKiC,QAAQC,SAAQ,SAACpF,GAAD,OAAOA,EAAEsP,iBA/VlC,wBAmWE,WACE,OAAOpM,KAAK6J,UApWhB,4BAuWE,WACE,OAAO7J,KAAK+J,gBAxWhB,KElBamD,GAAcpP,IAAOC,IAAV,mHAOXoP,GAAWrP,IAAOC,IAAV,oKCDRqP,GAAa,SAAC,GAA6B,IAA3BC,EAA0B,EAA1BA,QAASC,EAAiB,EAAjBA,KACpC,OACE,eAACJ,GAAD,WACE,cAACC,GAAD,CAAUI,QAASF,EAAnB,qBACA,cAACF,GAAD,CAAUI,QAASD,EAAnB,sBFNAE,GAAU1P,IAAOC,IAAV,uJAMT,qBAAG0P,YAA+BC,YAAJ,uFA0NnBC,OAvMf,WAAgB,IAAD,EACyBnP,mBAAuB,CAC3D,CACEoF,KAAM,mBACNuH,QAAS,IACTC,UAAW,IACXE,SAAU,IACVD,KAAM,IACNE,KAAM,OARG,mBACNqC,EADM,KACOC,EADP,OAWqBrP,mBAAS,IAX9B,mBAWNsP,EAXM,KAWKC,EAXL,OAY+BvP,mBAAS,IAZxC,mBAYNwP,EAZM,KAYUC,EAZV,OAamCzP,mBAAS,IAb5C,mBAaN0P,EAbM,KAaYC,EAbZ,OAciC3P,mBAAS,IAd1C,mBAcN4P,EAdM,KAcWC,EAdX,OAe2C7P,mBAAS,IAfpD,mBAeN8P,EAfM,KAegBC,EAfhB,OAgByB/P,mBAAS,IAhBlC,mBAgBNgQ,EAhBM,KAgBOC,EAhBP,KAiBPpP,EAAMd,iBAAuB,MAjBtB,EAkBuBC,oBAAS,GAlBhC,mBAkBNiP,EAlBM,KAkBMiB,EAlBN,OAmBmBlQ,mBAAS,GAnB5B,mBAmBNgN,EAnBM,aAoB+BhN,oBAAS,IApBxC,mBAoBNmQ,EApBM,KAoBUC,EApBV,OAqBuBpQ,oBAAS,GArBhC,mBAqBNqQ,EArBM,KAqBMC,EArBN,KAwBb9P,qBAAU,WACR,GAAIyO,EAAY,CACd3O,QAAQC,IAAI,YAAa6O,GACzBxP,EAAY,IAAIwL,EAChB9K,QAAQC,IAAI,iBAEZ,IAAMsG,EAAUhG,EAAIJ,QACpB2O,EAAY1L,SAAQ,SAACC,GAAY,IACvByB,EAAmDzB,EAAnDyB,KAAMuH,EAA6ChJ,EAA7CgJ,QAASC,EAAoCjJ,EAApCiJ,UAAWC,EAAyBlJ,EAAzBkJ,KAAMC,EAAmBnJ,EAAnBmJ,SAAUC,EAASpJ,EAAToJ,KAClDnN,EAAU8M,UAAUtH,EAAMuH,EAASC,EAAWC,EAAMC,EAAUC,EAAMC,EAAUnG,MAGhFyJ,GAAc,GACd1Q,EAAU6N,eAEX,CAACwB,EAAYG,EAAapC,IAE7BxM,qBAAU,WAAO,IAAD,EACR+P,EAAc,SAAC/I,GACf6I,IACY,WAAV7I,EAAEC,MACJ2I,EAAkBxQ,EAAU8L,eAC5B9L,EAAUyN,SAEE,MAAV7F,EAAEC,KACJ2I,GAAkB,KAQxB,OAFA,UAAAvP,EAAIJ,eAAJ,SAAa6H,iBAAkB,UAAYiI,GAEpC,kCAAM1P,EAAIJ,eAAV,aAAM,EAAa8H,oBAAoB,UAAWgI,MACxD,CAACF,IAEJ,IAoBMG,EAAmB,WACvBjB,EAAa,IACbE,EAAkB,IAClBM,EAAwB,IACxBJ,EAAoB,IACpBE,EAAmB,IACnBI,EAAe,KAcXQ,GAAY,WAChBrN,EAAKM,SAAQ,SAACpF,EAAG2L,GACf7G,EAAK6G,GAAL,2BACK3L,GADL,IAEEyG,KAAM,GACN+E,WAAY,GACZ9F,WAAOQ,EACPb,YAAQa,QA6BRkM,GACJpB,EAAUnH,QAAU,GACjBqH,EAAerH,QAAU,GACzB2H,EAAqB3H,QAAU,GAC/BuH,EAAiBvH,QAAU,GAC3ByH,EAAgBzH,QAAU,GAC1B6H,EAAY7H,QAAU,EAE3B,OACE,eAAC6G,GAAD,CACEnO,IAAKA,EACLoO,WAAYA,EACZnO,SAAU,EAHZ,UAKKuP,EAAa,cAAC,EAAD,CAAQzQ,UAAWA,IAC/B,gCAEI,gCACE,wCACA,uBAAOmF,KAAK,OAAO4L,YAAY,WAAWC,MAAOtB,EAAWuB,SAAU,SAACrJ,GAAD,OAAO+H,EAAa/H,EAAE9E,OAAOkO,aAErG,2CACA,gCACE,2CACA,uBAAO7L,KAAK,OAAO4L,YAAY,GAAGC,MAAOpB,EAAgBsB,UAAW,SAACtJ,GAAD,OAAOiI,EAAkBjI,EAAEC,WAEjG,gCACE,8CACA,uBAAO1C,KAAK,OAAO4L,YAAY,GAAGC,MAAOlB,EAAkBoB,UAAW,SAACtJ,GAAD,OAAOmI,EAAoBnI,EAAEC,WAErG,gCACE,6CACA,uBAAO1C,KAAK,OAAO4L,YAAY,GAAGC,MAAOhB,EAAiBkB,UAAW,SAACtJ,GAAD,OAAOqI,EAAmBrI,EAAEC,WAEnG,gCACE,kDACA,uBAAO1C,KAAK,OAAO4L,YAAY,GAAGC,MAAOd,EAAsBgB,UAAW,SAACtJ,GAAD,OAAOuI,EAAwBvI,EAAEC,WAE7G,gCACE,wCACA,uBAAO1C,KAAK,OAAO4L,YAAY,GAAGC,MAAOZ,EAAac,UAAW,SAACtJ,GAAD,OAAOyI,EAAezI,EAAEC,WAG7F,wBAAQsH,QAASyB,EAAjB,oBACA,wBAAQzB,QA3FD,SAACvH,GAChBA,EAAEE,iBAxBc,WAEhB,IAAMqJ,EAAY,CAChB3L,KAAMkK,EACN3C,QAAS6C,EACT3C,KAAMiD,EACNlD,UAAW8C,EACX5C,SAAU8C,EACV7C,KAAMiD,GAEFgB,EAAc,sBAAO5B,GAAP,CAAoB2B,IACxC1B,EAAe2B,GAcftE,GAEA8D,KAuFmCS,SAAUP,GAArC,wBACA,2CACCtB,EAAYvH,KAAI,SAACvJ,GAAD,OAAO,gCACrB4S,KAAKC,UAAU7S,GAChB,yBAAQyQ,QAAS,kBAxFR,SAAC3J,GACpB,IAAM3B,EAAU2L,EAAYjB,QAAO,SAAC7P,GAAD,OAAOA,EAAE8G,OAASA,KACrDiK,EAAe5L,GAsFkB2N,CAAa9S,EAAE8G,OAAtC,oBAAqD9G,EAAE8G,cAExDgK,EAAYjH,OAAS,GACpB,8BACE,wBAAQ4G,QAhIJ,WACXE,GACHiB,GAAc,IA8HJ,6BAMPC,GAAkB,cAAC,GAAD,CAAYtB,QAlFrB,WACdvO,QAAQC,IAAI,WACZX,EAAUyR,WACVZ,KAEAH,GAAc,GACdF,GAAkB,GAClBxQ,EAAU6N,YACV6C,GAAc,IA0EuCxB,KAlE1C,WACXlP,EAAUyR,WACVZ,KACAL,GAAkB,GAClBE,GAAc,GACdJ,GAAc,UGxJHoB,GAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCFdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,GAAD,MAEF/G,SAASgH,eAAe,SAM1BZ,O","file":"static/js/main.4af397a0.chunk.js","sourcesContent":["export const drawRect = (x: number, y: number, w: number, h: number, color: string | CanvasGradient | CanvasPattern, ctx: CanvasRenderingContext2D | undefined) => {\n    if (!ctx) return\n    ctx.fillStyle = color;\n    ctx.fillRect(x, y, w, h);\n  }\n  \nexport const drawCircle = (x: number, y: number, radius: number, color: string | CanvasGradient | CanvasPattern, ctx: CanvasRenderingContext2D | undefined) => {\n    if (!ctx) return\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fill()\n  }\n  \nexport const drawText = (text: string, x: number, y: number, color: string | CanvasGradient | CanvasPattern, ctx: CanvasRenderingContext2D | undefined) => {\n    if (!ctx) return\n    ctx.fillStyle = color\n    ctx.font = '8px helvetica'\n    ctx.fillText(text, x, y)\n  }\n  \nexport const drawStandardText = (text: string, ctx: CanvasRenderingContext2D) => {\n    //drawText(text, 30, 30, 'black')\n  }\n","import styled from 'styled-components';\n\nexport const CanvasWrapper = styled.div`\n  position: relative;\n  outline: none;\n  canvas {\n    margin-top: 32px;\n    box-shadow: -1px 0px 20px 20px #2b303aed;\n    border-radius: 14px\n  }\n`\n\nexport const WaveText = styled.div`\n  font-size: 24px;\n  position: absolute;\n  top: 20px;\n  right: 50%;\n  color: #f7f7f7;\n`","import React, { useEffect, useRef, useState } from 'react'\nimport { drawRect } from '../game/draw-functions';\nimport { GameState } from '../game/game-state';\nimport { CanvasWrapper, WaveText } from './canvas-styles';\ntype Props = {\n  gameState: GameState \n}\nexport const canvasWidth = 960\nexport const canvasHeight = 640\nexport const Canvas: React.FC<Props> = ({ gameState })  => {\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\n  const [context, setContext] = React.useState<CanvasRenderingContext2D | null>(null);\n  const [wave, setWave] = useState(1)\n  const wrapperRef = useRef<HTMLDivElement>(null)\n  console.log('canvas render');\n  \n  useEffect(() => {\n    if (canvasRef.current) {\n      const renderCtx = canvasRef.current.getContext('2d');\n      if (renderCtx && gameState) {\n        gameState.setContext(renderCtx)\n        gameState.incWave = (wave: number) => setWave(wave)\n        setContext(renderCtx);\n      }\n      // Draw a rectangle\n      if (context && gameState?.ctx) {\n        context.fillStyle = 'blue'\n        context.fillRect(5, 50, 100, 100);\n        drawRect(120, 150, 100, 100, 'red', gameState.ctx)\n      }\n    \n    }\n  }, [context, gameState]);\n\n  \n  return (\n    <CanvasWrapper \n      ref={wrapperRef}\n      tabIndex={0}\n      >\n      \n      <canvas\n        id=\"canvas\"\n        ref={canvasRef}\n        width={canvasWidth}\n        height={canvasHeight}\n      ></canvas>\n      <WaveText>{wave}</WaveText>\n    </CanvasWrapper>\n  );\n}\n","import { gameState } from \"../App\";\nimport { drawRect } from \"./draw-functions\"\n\nexport class Sprite {\n  id: number | string\n  x: number\n  y: number\n  startY: number\n  startX: number\n  width: number\n  height: number\n  speed: number\n  angle: number\n  color: string\n  ttl: number\n  \n  constructor(startX: number, startY: number, angle: number, width = 2, height = 2, color = 'green', ttl: number = 1) {\n    this.id = Math.random() // This should probably be changed. Could be just index of objects created right?\n    this.x = startX\n    this.y = startY\n    this.startX = startX\n    this.startY = startY\n    this.width = width\n    this.height = height\n    this.speed = 1\n    this.angle = angle\n    this.color = color\n    this.ttl = ttl // timeToLive\n  }\n\n  update () {\n    this.ttl--\n  }\n\n  isAlive () {\n    return this.ttl > 0\n  }\n  \n  draw () {\n    const { x, y, width, height, color } = this\n    drawRect(x, y, width, height, color, gameState.getContext())\n  }\n\n  reset () {\n    this.x = this.startX\n    this.y = this.startY\n  }\n\n}\n","import { gameState } from \"../App\";\nimport { drawRect } from \"./draw-functions\";\nimport { Sprite } from \"./sprite\";\n\n\nexport class Obj extends Sprite {\n  damageColor: string;\n  originalColor: string;\n  anchor: { x: number; y: number; };\n  speed: number;\n  hp: number;\n  originalHp: number;\n  hitTimeout: NodeJS.Timeout | null\n  constructor (x: number, y: number, color: string, damageColor: string, width: number, height: number, speed: number, hp: number) {\n    super(x, y, 0, width, height, color);\n    this.damageColor = damageColor\n    this.originalColor = color\n    this.anchor = {x: 0.5, y: 0.5}\n    this.speed = speed;\n    this.hp = hp;\n    this.originalHp = hp\n    this.hitTimeout = null\n  }\n\n  hit (dmg: number) {\n    if (!this.hitTimeout) {\n      \n      this.hp -= dmg\n      this.color = this.damageColor\n      this.hitTimeout = setTimeout(() => {\n        this.color = this.originalColor\n        this.hitTimeout = null\n      }, 1000)\n    }\n  }\n} \n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAJCAYAAADkZNYtAAAACXBIWXMAAN54AADeeAGWGQrUAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAPhJREFUGJVF0L8rxHEcx/HHx/d+RPejkEEZZZBJsUmZDCblVoPBYlMW0w3YLQZlYvcXKAMGq8gxUFac7hd3981w3+tey/vdq+e716t30NeZaV1b0uaRF6uK3ck7teEdArhwIGNXRloqcWN00NbSVVZyGJzbUxg+kv9lJCaLoQT+Qwt11G0Hlz58rUyau6bYJqd30E2gGn7w7TUlGDd1S2j3ugdEyUwle4SsiZS6iqHGrCjp2EggaCc1Gmh6jqx50VRSG4tUVkk/DqKflvBGTVPWZu8bx5YFJ0JuRqbWi4VOkXT1QcGOdVfBQEHZgtiiYFTkEzf23feBf7ETRzD3o1scAAAAAElFTkSuQmCC\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAICAYAAADA+m62AAAACXBIWXMAAN54AADeeAGWGQrUAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAANRJREFUGJUtzzEvA2EAgOHnu7tcNS1KamRgkSZit9osYqGLXeI3SPwTA2bRxGDiJxjEYJQ0XYqgLXrXO4MO7/gMbwCl4MKOQltsTaFUeBY5d+hOUAa3ar5cS21L8d6i+cQEY6Vcx4aD2J4zC3YtoonxMqs96qgKYut6loIbnxpmNTA/rYIPdBu81tDtJ37FfjBChBwxMoQh2RyRKPGmI9M2QhXpFBQYZ+QvDHQSfUeGVqS2VPC9SRSoP/wP5e5NHAdwKhIcKO2LZlqShHLwqHDpxBXKP6z7Qp+q4mSgAAAAAElFTkSuQmCC\"","import { gameState } from \"../App\";\nimport { findGridUnit, getXY, grid, gridCellSize, gridCols, gridRows, typeBlood, typeEnemy } from './index'\nimport { Obj } from './object'\nimport { collision } from './helper-functions'\nimport enemy_1 from '../images/enemy/enemy_1.png'\nimport enemy_2 from '../images/enemy/enemy_2.png'\n\nconst images = [\n  enemy_1,\n  enemy_2\n]\n\nconst FIND_CLOSEST_TARGET_TIMER = 100\nconst MOVE_TIMER = 0\n\nconst getDistance = (myCol: number, myRow: number, targetCol: number, targetRow: number) => {\n  // Math.abs because -2 should count same as +2\n  // Distance now is The amount of steps needed rather than actual distance\n  const rowDistance = Math.abs(myRow - targetRow)\n  const colDistance = Math.abs(myCol - targetCol)\n  const distance = rowDistance + colDistance\n  return distance\n}\n\nexport class Enemy extends Obj {\n  id: number\n  target: any\n  direction: string\n  originalSpeed: any\n  limit: number\n  hp: number\n  ttl: number\n  damage: number\n  prevGridUnit: number\n  currentGridUnit: number\n  findClosestTargetTimer: number\n  moveTimer: number\n  constructor (x: number, y: number, color: string, damageColor: string, width: number, height: number, speed: number, hp: number, target: any, id: number) {\n    super(x, y, color, damageColor, width, height, speed, hp) \n    this.target = target\n    this.id = id\n    this.direction = ''\n    this.originalSpeed = width\n    this.limit = 5\n    this.hp = width + height\n    this.ttl = 10\n    this.damage = 10\n    this.prevGridUnit = -5\n    this.currentGridUnit = -5\n    this.findClosestTargetTimer = FIND_CLOSEST_TARGET_TIMER\n    this.moveTimer = MOVE_TIMER\n  }\n\n  die (angle: number) {\n    // this.drop ()\n    this.ttl = 0\n    const {x, y} = getXY(this.currentGridUnit)\n    gameState.incBlood(x, y, angle, this.width, this.height)\n    gameState.removeFromEnemiesGridPositions(this.currentGridUnit, grid[this.currentGridUnit].enemy?.id)\n  }\n\n  isAlive () {\n    return this.ttl > 0\n  }\n\n  findClosestTarget = () => {\n\n    if (!grid[this.currentGridUnit]) {\n      return\n    }\n    const myCol = grid[this.currentGridUnit].col\n    const myRow = grid[this.currentGridUnit].row\n    // get row and column of a player\n    \n    const currentTargetDistance = getDistance(\n      myCol,\n      myRow,\n      grid[this.target.currentGridUnitPosition].col,\n      grid[this.target.currentGridUnitPosition].row\n    )\n    \n    gameState.players.forEach((player) => {\n      const distance = getDistance(\n        myCol,\n        myRow,\n        grid[player.currentGridUnitPosition].col,\n        grid[player.currentGridUnitPosition].row\n      )\n      if (distance < currentTargetDistance || (this.target.isDead && !player.isDead) ) {\n        // change target\n        this.target = player\n      }\n    })\n\n  }\n\n\n  drop () {\n    // Pickup will increase playerLevel until 5, then kill all enemies\n    // so decrease chance of drop\n    if (gameState.players[0].level < 5) {\n      const rand = Math.floor(Math.random() * 20)\n      if (rand === 1) {\n        gameState.incPickup(this.x, this.y)\n      }\n    } else {\n      const rand = Math.floor(Math.random() * 200)\n      if (rand === 1) {\n        gameState.incPickup(this.x, this.y)\n      }\n    }\n  }\n\n\n  update() {\n    this.move()\n\n    if (this.currentGridUnit === this.target.currentGridUnitPosition) {\n      this.target.hit(1)\n    }\n  }\n\n  move() {\n    if (this.moveTimer > 0) {\n      this.moveTimer--\n      return\n    }\n    this.moveTimer = MOVE_TIMER\n    \n    // guess I should change this to targetCol and row?\n    // or update x and y according to grid[index]\n\n\n    // If enemy is outside of map\n    if (this.x < 0 || this.x + this.width > gameState.canvasWidth || this.y < 0 || this.y + this.height > gameState.canvasHeight) {\n      \n      const targetX = Math.floor(this.target.x)\n      const targetY = Math.floor(this.target.y)\n\n      if (this.x <= targetX) {\n        this.direction = 'right'\n        this.x += 1 \n      }\n      if (this.x >= targetX) {\n        this.direction = 'left'\n        this.x -= 1 \n      }\n      if (this.y <= targetY) {\n        this.direction = 'down'\n        this.y += 1\n      }\n      if (this.y >= targetY) {\n        this.direction = 'up'\n        this.y -= 1\n      } \n      return \n    }\n    if (this.limit > 0) {\n      this.limit--\n      return\n    }\n    this.limit = 5\n  \n    // Inside of map:\n\n    if (this.currentGridUnit === null || this.currentGridUnit === undefined || this.currentGridUnit < 0) {\n      this.currentGridUnit = findGridUnit(this.x, this.y)\n    }\n\n    this.prevGridUnit = this.currentGridUnit ?? findGridUnit(this.x + this.width/2, this.y + this.height/2)\n    // Find direction depending on col and row\n    const targetsRow = grid[this.target.currentGridUnitPosition].row\n    const targetsCol = grid[this.target.currentGridUnitPosition].col\n    \n    const { col, row } = grid[this.currentGridUnit]\n    let xDir = '' \n    let yDir = ''\n    this.direction = ''\n    if (targetsRow < row) {\n      yDir = 'up'\n    }\n    if (targetsRow > row) {\n      yDir = 'down'\n    }\n    if (targetsCol < col) {\n      xDir = 'left'\n    }\n    if (targetsCol > col) {\n      xDir = 'right'\n    }\n\n    // Some randomness in enemy movement\n    const random = Math.random()\n    if (random < 0.2 || random > 0.8) {\n      this.direction = ''\n    } else if (random <= 0.5) {\n      this.direction = xDir\n    } else {\n      this.direction = yDir\n    }\n\n    // change grid depending on direction\n    switch (this.direction) {\n      case 'up': {\n        if (grid[this.currentGridUnit - gridCols] && grid[this.currentGridUnit - gridCols]?.type !== typeEnemy) {\n          this.currentGridUnit -= gridCols\n        }\n        break\n      }\n      case 'down': {\n        if (grid[this.currentGridUnit + gridCols] && grid[this.currentGridUnit + gridCols]?.type !== typeEnemy) {\n          this.currentGridUnit += gridCols\n        }\n        break\n      }\n      case 'left': {\n        if (grid[this.currentGridUnit -1] && grid[this.currentGridUnit -1]?.type !== typeEnemy) {\n          this.currentGridUnit -= 1\n        }\n        break\n      }\n      case 'right': {\n        if (grid[this.currentGridUnit + 1] && grid[this.currentGridUnit + 1]?.type !== typeEnemy) {\n          this.currentGridUnit += 1\n        }\n        break\n      }\n      default: break\n    }\n\n    if (this.currentGridUnit !== this.prevGridUnit) {\n      gameState.addToEnemiesGridPositions(this.currentGridUnit, this)\n      gameState.removeFromEnemiesGridPositions(this.prevGridUnit, this.id)\n    }\n\n    // check collision with other enemies\n    // check collision with enemy\n\n\n    // move one grid at the time\n    // direction= 'up'\n      // cell = this.cellIndex - gridCols, right?\n      // down is + gridCols\n    // left/right = + OR - 1\n    \n    // If outside of map:\n      // Ignore gridCells, just move x and y\n  }\n}","import { gameState } from \"../App\";\nimport { collision } from './helper-functions'\nimport { findGridUnit, grid } from './index'\nimport { Obj } from './object'\nimport player_idle from '../images/player/player_idle.png'\nimport player_running_1 from '../images/player/player_running_1.png'\nimport player_running_2 from '../images/player/player_running_2.png'\nimport player_shooting from '../images/player/player_shooting.png'\nimport player_dead from '../images/player/player_dead.png'\n\nconst images = [\n  player_idle,\n  player_shooting,\n  player_running_1,\n  player_running_2,\n  player_dead\n]\nlet ammo = 20\n\n// full circle in radians:  2 * Math.PI \n// 2 * Math.PI * 180 / Math.PI === 360degrees\n\nexport class Player extends Obj {\n  shootingSpeedInterval: NodeJS.Timeout | null\n  animationShootingSpeedInterval: number\n  rotateSpeedInterval: null\n  pickupInterval: null\n  bullets: number\n  collisionInterval: null\n  collisionPickupInterval: NodeJS.Timeout | null\n  level: number\n  drive: boolean\n  reverse: boolean\n  steerLeft: boolean\n  steerRight: boolean\n  brake: boolean\n  isShooting: boolean\n  controlKeyGas: undefined\n  controlKeyRight: undefined\n  controlKeyReverse: undefined\n  controlKeyLeft: undefined\n  controlKeyShoot: undefined\n  currentGridUnitPosition: number\n  name: string\n  sprites: any[]\n  shootingSprite: any\n  loadedImages: number\n  currentImage: number\n  animationSpeed: number\n  isDead: boolean\n  shouldDrawFireEffect: boolean\n  element: any\n  constructor (name: string, x: number, y: number, color: string, damageColor: string, width: number, height: number, speed: number, hp: number) {\n    super(x, y, color, damageColor, width, height, speed, hp)\n    this.shootingSpeedInterval = null\n    this.animationShootingSpeedInterval = 0\n    this.rotateSpeedInterval = null\n    this.pickupInterval = null\n    this.bullets = ammo\n    this.collisionInterval = null\n    this.collisionPickupInterval = null\n    this.level = 1\n    this.name = name\n    this.drive = false\n    this.reverse = false\n    this.steerLeft = false\n    this.steerRight = false\n    this.brake = false\n    this.isShooting = false\n\n    this.controlKeyGas = undefined\n    this.controlKeyRight = undefined\n    this.controlKeyReverse = undefined\n    this.controlKeyLeft = undefined\n    this.controlKeyShoot = undefined\n\n    this.currentGridUnitPosition = 0\n    this.sprites = images.map((src) => {\n      const image = new Image(width, height)\n      image.src = src\n      image.onload = () => {\n        console.log('loaded', src)\n        this.loadedImages++\n      }\n      return image\n    })\n    this.shootingSprite = new Image(width, height)\n    this.loadedImages = 0\n    this.currentImage = 0\n    this.animationSpeed = 30\n    this.isDead = false\n    this.shouldDrawFireEffect = false\n  }\n\n  stayInsideMap () {\n    if (this.x <= 0) this.x = 1;\n    if (this.x + this.width >= gameState.canvasWidth) {\n      this.x = gameState.canvasWidth - this.width\n    }\n    if (this.y <= 0) this.y = 1;\n    if (this.y + (this.height / 2) >= gameState.canvasHeight) {\n      this.y = gameState.canvasHeight - this.height\n    }\n  }\n\n  incLevel () {\n    if (this.collisionPickupInterval) return\n    this.collisionPickupInterval = setTimeout(() => {\n      this.collisionPickupInterval = null\n    }, 200)\n    this.level++\n  }\n\n  shoot = () => {\n    if (this.bullets <= 0) {\n      setTimeout(() => {\n        this.bullets = ammo * this.level / 2\n      }, 750)\n    }\n\n    if (this.shootingSpeedInterval) return\n      if (this.bullets > 0) {\n        const centerX = this.x + this.width / 2\n        const centerY = this.y + this.height / 2\n          \n        gameState.incProjectiles(centerX, centerY, (this.angle - Math.random() * 10) * Math.PI / 180)\n        gameState.incProjectiles(centerX, centerY, (this.angle - Math.random() * 10)* Math.PI / 180)\n        gameState.incProjectiles(centerX, centerY, this.angle * Math.PI / 180)\n        gameState.incProjectiles(centerX, centerY, (this.angle + Math.random() * 10) * Math.PI / 180)\n        gameState.incProjectiles(centerX, centerY, (this.angle + Math.random() * 10) * Math.PI / 180)\n\n        this.bullets -= 1\n        this.shouldDrawFireEffect = true\n        this.shootingSpeedInterval = setTimeout(() => {\n          this.shootingSpeedInterval = null\n        }, 500)\n      } \n\n  }\n  // shoot = () => {\n  //   if (this.bullets <= 0) {\n  //     setTimeout(() => {\n  //       this.bullets = ammo * this.level / 2\n  //     }, 500)\n  //   }\n\n  //   if (this.shootingSpeedInterval) return\n  //     if (this.bullets > 0) {\n  //       const centerX = this.x + this.width / 2\n  //       const centerY = this.y + this.height / 2\n  //       gameState.incProjectiles(centerX, centerY, this.angle)\n  //       this.bullets -= 1\n\n\n  //       this.shootingSpeedInterval = setTimeout(() => {\n  //         this.shootingSpeedInterval = null\n  //       }, 100)\n  //     } \n  // }\n  drawHealthBar (ctx: CanvasRenderingContext2D) {\n    const { width, height } = this\n    if (this.color === this.damageColor) {\n      const barHeight = -height\n      ctx.fillStyle = '#ff0000';\n      ctx.fillRect(-width / 2, barHeight, width, 3);\n      ctx.fillStyle = '#33ef02';\n      ctx.fillRect(-width / 2, barHeight, width * (this.hp / this.originalHp), 3);\n    }\n  }\n\n  draw () {\n  \n    const { x, y, width, height } = this\n    const ctx = gameState.getContext()\n    if (!ctx || this.loadedImages < images.length -1) return\n    ctx.save()\n    ctx.translate(x + width / 2, y + height / 2)\n\n    if (this.hp > 0) {\n      this.drawHealthBar(ctx)\n    }\n    ctx.rotate((this.angle + 90) * Math.PI / 180)\n    // ctx.rotate(this.angle + (90 * Math.PI / 180))\n    ctx.drawImage(\n      this.sprites[this.currentImage],\n      Math.floor(-width / 2),\n      Math.floor(-height / 2),\n      width,\n      height\n    )\n      \n\n    ctx.restore()\n    \n    if (this.shouldDrawFireEffect) {\n      this.drawFireEffect()\n    }\n  }\n  drawFireEffect = () => {\n    this.shouldDrawFireEffect = false\n    const ctx = gameState.getContext()\n    if (!ctx) return\n    const centerX = this.x + this.width / 2\n    const centerY = this.y + this.height / 2\n    const angle = this.angle * Math.PI / 180\n    ctx.save()\n    ctx.translate(centerX, centerY);\n    ctx.rotate(angle);\n    ctx.translate(-centerX, -centerY);\n\n    ctx.fillStyle = '#A9F4FF';\n    ctx.fillRect(centerX + 4, centerY, 4, 4)\n    ctx.restore()\n  }\n\n  addKeyListeners (element: any) {\n    this.element = element\n    element.addEventListener('keydown', this.keyDown)\n    element.addEventListener('keyup', this.keyUp)\n  }\n\n  removeEventListeners () {\n    this.element.removeEventListener('keydown', this.keyDown)\n    this.element.removeEventListener('keyup', this.keyUp)\n  }\n\n  setUpControls (gas: any, right: any, reverse: any, left: any, shoot: any) {\n    this.controlKeyGas = gas\n    this.controlKeyRight = right\n    this.controlKeyReverse = reverse\n    this.controlKeyLeft = left\n    this.controlKeyShoot = shoot\n  }\n\n  keySet (e: { key: any }, setTo: boolean) {\n    if (e.key === this.controlKeyGas) {\n      this.drive = setTo\n    }\n    if (e.key === this.controlKeyRight) {\n      this.steerRight = setTo\n    }\n    if (e.key === this.controlKeyReverse) {\n      this.reverse = setTo\n    }\n    if (e.key === this.controlKeyLeft) {\n      this.steerLeft = setTo\n    }\n    if (e.key === this.controlKeyShoot) {\n      this.isShooting = setTo\n    }\n  }\n\n  keyDown = (e: KeyboardEvent) => {\n    if (e.key === 'Escape') return\n    e.preventDefault()\n    this.keySet(e, true)\n  }\n\n  keyUp = (e: any) => {\n    e.preventDefault()\n    this.keySet(e, false)\n  }\n\n  update () {\n    if (!this.isDead && this.hp <= 0) {\n      this.die()\n    }\n    this.move()\n  }\n\n  animation () {\n    this.animationSpeed--\n    if (this.animationSpeed >= 0) {\n      return\n    }\n    if (this.animationSpeed < 0) {\n      this.animationSpeed = 6\n    }\n\n    if (this.drive) {\n      if (this.currentImage !== 2) {\n        this.currentImage = 2\n      } else {\n        this.currentImage = 3\n      }\n    } else if (this.reverse) {\n      if (this.currentImage !== 2) { // make function of this.\n        this.currentImage = 2\n      } else {\n        this.currentImage = 3\n      }\n    } else if (this.shootingSpeedInterval) {\n      this.currentImage = 1\n      \n    } else {\n      this.currentImage = 0\n    }\n    \n  }\n  \n  move() {\n    if (this.isDead) return\n    if (this.ttl <= 0) return // ttl har ju mer med hur länge ska synas på skärmen\n    \n    this.animation()\n    if (this.drive) {      \n      this.speed = 5\n    } else {\n      this.speed = 0\n    }\n\n    if (this.isShooting) {\n      this.shoot()\n    }\n\n    if (this.reverse) {\n      this.speed = -0.5\n    }\n\n    if (this.steerLeft) {\n      this.angle -= 8\n      // this.angle -= 0.1\n    }\n\n    if (this.steerRight) {\n      this.angle += 8\n      // this.angle += 0.1\n    }\n    if (this.angle > 360) {\n      this.angle = 0\n    }\n    if ( this.angle < 0) {\n      this.angle = 360\n    }\n    \n\n    this.stayInsideMap()\n    // this.collisionCheckPickup()\n\n    this.x += Math.cos(this.angle * Math.PI / 180) * this.speed;\n    this.y += Math.sin(this.angle * Math.PI / 180) * this.speed;\n    // this.x += Math.cos(this.angle) * this.speed;\n    // this.y += Math.sin(this.angle) * this.speed;\n\n    // which grid unit am I in?\n    const currentGridUnit = findGridUnit(this.x + this.width/2, this.y + this.height/2)\n    if (grid[currentGridUnit]) {\n      this.currentGridUnitPosition = currentGridUnit\n    }\n    \n  } \n\n  collisionCheckPickup () {\n    // Either level up or kill all enemies.\n    const pickups = gameState.getPickups()\n    pickups.forEach((p) => {\n      if (collision(this, p)) {\n        p.ttl = 0\n        if (this.level < 5) {\n          this.incLevel()\n        } else {\n          gameState.getEnemies().forEach((x) => {\n            x.die()\n          })\n\n        }\n      }\n    })\n  }\n\n  die () {\n    console.log('die');\n    this.isDead = true\n    this.currentImage = 4\n    gameState.incBlood(this.x, this.y, 0, 20, 20)\n    // gameState.stopGame()\n  }\n  resurrect () {\n    this.isDead = false\n    this.hp = this.originalHp\n  }\n}","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAMCAYAAABvEu28AAAACXBIWXMAAN6IAADeiAGXN/JwAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAglJREFUKJGF0T9IlWEUx/HveZ7nvtd8TUOjsIuKm1tTgktDS9AihbVIEKFQ0SAtOTo2SBANDhG0BHFpEVLI/hilZg1CQwQ1lZCamre696rve9/nNFxfuYHkD872nM95DkeoJgt8AXLABrAILADvgc87tQwk7BMLfAT0P1XZGTAPdO8Hnhi41P/o/NnexT2gGPAHw/DT6Mjwt8f3717J5/M2bXS1ysvJ8aA+G1yw1iwPDA6OZpzNGTFN35eWg9m5ue5Xr9/YShTd7Gg7dhUYM8WVLmAIQGqcupmpJw+ds+da2zrHjbW9gAdM+kBVAZ2pSKZvYXpiCBhG5Frf5etjKWQAnZ9++gHoas11iHH2n9+mSZKEzWIx+V1YX4vKpcrKj6UjPtxuciny7vnkA9QfdkE2Y5zdy1BArLWEjY22VPrT7A4kmVxH50bPqTObAgSzLyb6nchtRQ65TMDRXHu6SxGRhlooXbdcLvJzdWVdVFuw9rQBYjwXVSUASCoxiU82AWoQUARBxVD23pOtqycMG1pAfuGTEQNoYaNwI4qjbVFWVVULayuFShwvqdfKLiRVbHsravDeVy+gCqohyvHdqz3L55vC5vp7Iu6kGA286pYR0+qsIxNksRmHTzzqPUkSE0XRDkSswtfa86dz5e3UZI84uaOi7aJYwKjHAxgjXqtrRh5KRmVdVG79BXYK6X6qFyiXAAAAAElFTkSuQmCC\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAPCAYAAADtc08vAAAACXBIWXMAAN6IAADeiAGXN/JwAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAgZJREFUKJGdkstLlGEUh5/zvt98n2PjXGQsiyDoYltb2KZcSLQWctEuooggqr+gNu0K2gQtpP8gKIpqIhAnsGwC14FUbiQdZ0a0pvG7OPOeFl4QSggPHM7ix+/h3Cx7iJMHukf7Mv50XyboMXsBCHIb6FV0cE8AYGmzNr3/dVTKpcOCHXTaGR5//Ohc5cMUArVdAdPTT9MSZy6AjIlyBmW/4hAkrFUXfgI4tPEX4PPEmwHjeTdp28ueb3uM51VTqWAWI887aHl+ofFy7tvce6BfVKJtwNTU68I+k3mRzReGU0FajJEtqX8zzwLXC9nCxLETA9nvX2cB3PYSvbbN5YvFU0G6e6cZ0BawDog611Q4f+najW4AFV21AJXJ0hUx5lmuUMyJCM51SOIEAdQ5XzvOGmsRkUCB3nw+MzR0+kl15st9qUyW7oHcFTEcOnIUgCSO8YOAJAqxno/17EYvzoExNKo/SKIQ0KsGzC0AVUcUhQD4QUDHtfG70ljPksQRURjiRAl//9o0A8gdA/p2a9qVpQXWWs0NSSztJCaOQkDoSqeJWy1Wl+s7j9ZrwDwEOgBOlZX6Esu1RdaTGON5GCOsxxH1xXlWGjVUFSABEHgnAJ/KpYuiMg7kdnusf8RHXGps+14z5VfFDt6ownFVDgoUQYqgXUAeyAIo2jSY8TUJHoyMjLT/AJtqzZ02ngfVAAAAAElFTkSuQmCC\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAQCAYAAADwMZRfAAAACXBIWXMAAN6IAADeiAGXN/JwAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAkVJREFUOI2Nks1LVGEUxn/nvXeuoo7O+IEJBllMH8tAUIQkC0OFtrXt3xBaRa2ENlkrC6JlKdbGSsg2iZEL3eQyjEprdHKc6d479868p4UVOqn17M778Xuf95xH2KXj6XSTF0WzChlg3lg7sRIE04ByiMzuojaOO4GzAimBETVm6nR9/Rggh0Gc3UU2irLNrvvCwAVEmn8t97V63tWWRCLV6nn5zTjOVjvb88Li7GxTJWEn/CDMTNweX89ls5fCMJAwCPGLRUphCLAu8AjV+RXfn94DmZuba0jV6NuW9s4zIrKv/VIQ8Gn1I++Xl5mZnHrz7N3iORFRAVBVWXj9fLKxKX25MdXiALNAL9B4UB8K+S22v288TW4UrjgAQ/09w4LcbG49smqMSQMngBpUy4iY/SA1tbUa+sWTfq0TuQuvZu4iMijKtnHdrj0nRdz9AFEURq5xjZPwilIqX3QFrqlqnQJBsUBdQ/KgHwCgVkm4nqeqRKGfwtDhKvIVtAsob21+c8txTF0yieM4qCrKTpjiKMbaCtZWiEol/B8F1FqAo66I3rKqY4KkVbVSyOdsIZ9LHGoHQLEIRhUxPQPD98XIdSAGWQNVoKxQEiVSpQLyd+wFI8iSlLTDAPSeH76HpTsOg6VSGHrszL5GBU8EB7Q6N5vAlCfBQO/IyPaezccP7rwUpetYJtNfqdgekHaLpgRJoXywkTzpGxrKVZv6M8LxG6M9G18+D7a1dYx29w+tAdP/7Es1xMb+KXHdtcAvPvzfy7/1E3K6/1aG9NiBAAAAAElFTkSuQmCC\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAQCAYAAADwMZRfAAAACXBIWXMAAN6IAADeiAGXN/JwAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAl1JREFUOI2NkU1IVFEYhp/v3Ds/OuqAUJoURUqQFRUUQgXWJlsk7SpwFRRtCqJNUIvatAqCoIi2/aBIkSWNEUktxIxKsCyRDBSH0DAr9er8nHu/Fo0y1mS9cBbn5TvPeXk/IU81EHFisUcC24FehZslnnf7DWRZQpJ/2RiLVVj4BMTmPRVpc2dmDr2HzH9BAGri8WrX2jtAXZ49LtAi0O56Xs9b8P4K6ep6UOpmwtcyc+n6YwebmgVOAZFINEo6lZofSwGtCv2DnndpEaS7u7XIZOPPI+GiLbGy0ofF0dKZTDa1FTHrQ6FQ+HMySeLuPXpf9PDxwwBl8Xjycuv12l27DkwLgKrKq67OhxWVq/YbxwAEgMkL6QMOgB8EevJwU3/T8SMb1lSvHXF9d7cAvOzsuBCNxc6XL1+BgubiiSoZ1SBtjCld3FxQNzo6NGd88wTok56niVqM9DmOO1CxcvVGa7MSCoW1UOkaBCrGyHhyeNZamwwgcJBiVw3nBFzft5u+jn+mfFllwa39ymbUWjttrU0B6wxkfSeoc0VlE4IF3HRqjrHkCOFIFMd1EDFEotEcU7HZrPFmpsqAshw2pJYpF6EKcBcia0A6NbvwuTf9o2AoVANEjBgjRoQzQF/hySUkIgLNO/bsGxKARCIRKY+as6AngPLc2DSwaCuqmhalQxx5bDPm/s6Ghi/wW4Gv29uL/RJnr2LqRbVKoQRlCsNQ2gbvJkaHb6gGQ99/fG04evrC5Pw7Nx+yrbFxFmjLnT9068pFpr5NtvjKM2BzQci/9G1ibBA1kxiu5vs/Afr98xKJZHL6AAAAAElFTkSuQmCC\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAATCAYAAAB2pebxAAAACXBIWXMAAN6IAADeiAGXN/JwAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAvRJREFUOI11kV9M1XUYxj/v9/c7HKEok9hgxuTPjhOMFdVCuwlwK6EEp8Xa2mrrottyrbF13b1rbW2tzav+GLmWLgQSzhkXAsJ0ICLpgcMCNNfBJjYcR/n9ni7K4pwDz+Xzfd/neb7Pa2yBhdnZp2/fTh/t6e/vSKfTFUcOd0Sqq6oiwAJwF7jsB3xSHoul85Z/m519fnE+ObiYSgZ9Paenfc8LPM8LT538+uLSfDLx5tEjcw0Nzy53tB9aXphLXlQi4bss91Sy3TkNE5qA6z+c+rGutLTU1dXW2vTVa88FQdg0l0pVT0xMlqyurkadUbO066l3baPIYio5Y2bzkloBlpZuUFhUSMmOHQCsrKzw4Ucfc7ijg18GBvjis+PnBMWWnWT2HKadBncQjUBW0lyYswGF2udGB3svj8R72wFCd/8dE1cQjUg3MPqRrgLhZiIKFSBWfBynTZwYG+pvqKysWwQ6L40kuqLRok+LHi1+3Pcjj0m6Fwbrvzvn3XLOk9B2GRkgZvCTJRIJv1BrCQwtpP9q7uzsDEbjfSeF6g3+8CIRthUVlRf428r8aEFxJFLwwMyi/6Y7uxbwtgGMDfVXhEE4KfTV/pa2rtF4703gGtC0MT0wA/q+vGbv59HonftlZc+sAvxX7OhAXzNOZ3AME/IKZkmkWFaRMCpsal/Lwfdz+P8xMvRzrVv3vsGsWqg47zoibo56iUlJaw77tvFA63dZQ/tffn0mdLogdGWL8z4pURLCuMNNA+sAfu6UyT0BPPingtxH6pAte6Z044GDxx/SeW6ycApUgzG5SRIfCycEb2WTOXBm1yXuIeolxjHdBdtpEAM8w9YFlVk7eV4hbyDGQ3N7zdl5w6oM9oCtSdyU0Qr6cssk3d3dnqAFU9dLza/+ChwDjp0f7Nnlyd+N0yELeQ+nM9lVbcDw0NkGF9iYs7DixebXbuX1JdmFeN8JjKY/17Snra0tk/edTFg4ZdgLmwkAmJnI6AMgs/0R7X7I/w0+Y0jqdCiXQAAAAABJRU5ErkJggg==\"","import { Enemy } from './enemy';\nimport { Player } from './player';\nimport enemy_1 from '../images/enemy/enemy_1.png'\nimport enemy_2 from '../images/enemy/enemy_2.png'\nimport { canvasHeight, canvasWidth } from '../canvas/canvas';\nimport { drawCircle } from './draw-functions';\n\nconst images = [\n  enemy_1,\n  enemy_2\n]\n\nlet loadedImages = 0\n\n\nexport const playerStart = 2\nexport const darkBrick = 3\nexport const lightBrick = 4\nexport const gridWidth = 10;\nexport const gridHeight = 10;\nexport const gridCellSize = 5\nexport const gridCols = Math.floor(canvasWidth / gridCellSize);\nexport const gridRows = Math.floor(canvasHeight / gridCellSize);\nexport let grid: {\n  type: string,\n  background: string,\n  col: number,\n  row: number,\n  enemy?: Enemy,\n  player?: Player,\n  x: number,\n  y: number\n}[] = new Array(gridCols * gridRows); // 4600 if gridCellSize = 10\nexport const darkSquare = 'darkSquare'\nexport const typeEnemy = 'enemy'\nexport const typePickup = 'pickup'\nexport const typeBlood = 'blood'\n\nconst enemyImages = images.map((src) => {\n  const image = new Image(gridCellSize, gridCellSize)\n  image.src = src\n  image.onload = () => {\n    console.log('loaded', src)\n    loadedImages++\n  }\n  return image\n})\nfunction insertSquares () {\n  for (let eachRowFirst = 0; eachRowFirst < gridRows; eachRowFirst++) {\n    for (let eachColFirst = 0; eachColFirst < gridCols; eachColFirst++) {\n      const index = colRowIndex(eachColFirst, eachRowFirst)\n      grid[index] = {\n        type: '',\n        background: '',\n        col: eachColFirst,\n        row: eachRowFirst,\n        x: eachColFirst * gridCellSize,\n        y: eachRowFirst * gridCellSize\n      }\n    }\n  }\n}\n\ninsertSquares()\n\nexport function colRowIndex (col: number, row: number) {\n  return col + gridCols * row\n}\n\nexport const getXY = (index: number) => {\n  const x = (index % gridCols) * gridCellSize\n  const y = Math.floor((index / gridCols)) * gridCellSize\n  \n  return {\n    x,\n    y\n  }\n}\n\nexport function findGridUnit (centerX: number, centerY: number) {\n  const gridCol = Math.floor(centerX / gridCellSize)\n  const gridRow = Math.floor(centerY / gridCellSize)\n  return colRowIndex(gridCol, gridRow)\n}\nconst radius = gridCellSize / 2\nexport function drawMap(ctx: any) {\n  // console.time('drawMap')\n  \n  for (let i = 0; i < grid.length; i++) {\n    const { type, background, col, row,x, y } = grid[i]\n    \n    if (type === typeEnemy) {\n      const color = '#28c61a'\n      drawCircle(x, y, radius, color, ctx)\n      // ctx.drawImage(\n      //   enemyImages[Math.random() > 0.5 ? 0 : 1], // Does it matter which image now when size is so small?\n      //     Math.floor(x),\n      //     Math.floor(y),\n      //     gridCellSize,\n      //     gridCellSize\n      //   )\n    }\n  }\n  // console.timeEnd('drawMap')\n}\n\n\n\nexport const createNewPlayer = (\n  name: string,\n  x = 0,\n  y = 0,\n  color = 'blue',\n  dmgColor = 'green',\n  width = gridCellSize * 2,\n  height = gridCellSize * 2,\n  speed = 0,\n  hp = 10\n) => new Player(\n  name,\n  x,\n  y,\n  color,\n  dmgColor,\n  width,\n  height,\n  speed, // Not sure about speed\n  hp \n)\n\nexport const createEnemy = \n  (x: number, y: number, width: number, height: number, target: any) => \n    new Enemy(\n      x,\n      y,\n      'blue',\n      'green',\n      width,\n      height,\n      Math.floor(Math.random() * 10) + 5,\n      width / 3,\n      target,\n      Math.random()\n    )\n\n","import { gameState } from \"../App\";\nimport { drawCircle } from './draw-functions'\nimport {findGridUnit, grid, gridCols, typeEnemy } from './index'\nimport { Sprite } from './sprite'\n\nexport class Projectile extends Sprite {\n  prevGridUnit: number\n  currentGridUnit: number\n  constructor(startX: number, startY: number, angle: number) {\n    super(startX, startY, angle, 2, 5, '#A9F4FF')\n    this.speed = 10\n    this.ttl = 10\n    this.currentGridUnit = findGridUnit(this.x + this.width/2, this.y + this.width/2)\n    this.prevGridUnit = this.currentGridUnit\n  }\n\n  isAlive() {\n    return this.ttl > 0\n  }\n\n  move () {\n    this.x += Math.cos(this.angle) * this.speed\n    this.y += Math.sin(this.angle) * this.speed \n\n    \n\n    // die if outside of map\n    if (this.x < 0 || this.x > gameState.canvasWidth || this.y < 0 || this.y > gameState.canvasHeight) {\n      this.ttl = 0\n      return\n    }\n\n    // Enemy collision\n    this.prevGridUnit = this.currentGridUnit ?? findGridUnit(this.x + this.width/2, this.y + this.width/2)\n    this.currentGridUnit = findGridUnit(this.x + this.width/2, this.y + this.width/2)\n    if (grid[this.currentGridUnit] === undefined) return\n    let enemyGridCell = -1\n    if (this.prevGridUnit !== this.currentGridUnit) {\n      if (grid[this.currentGridUnit].type === typeEnemy) {\n        enemyGridCell = this.currentGridUnit\n      } else if (grid[this.currentGridUnit + gridCols]?.type === typeEnemy) {\n        enemyGridCell = this.currentGridUnit + gridCols\n      } else if (grid[this.currentGridUnit +1]?.type === typeEnemy) {\n        enemyGridCell = this.currentGridUnit + 1\n      } else if (grid[this.currentGridUnit -1]?.type === typeEnemy) {\n        enemyGridCell = this.currentGridUnit - 1\n      }\n      if (enemyGridCell > 0) {\n        grid[enemyGridCell].enemy?.die(this.angle)\n        this.ttl = 0\n      }\n    }\n\n  }\n\n  update () {\n    this.move()\n  }\n\n  draw () {\n    const { x, y, width } = this\n    drawCircle(x, y, width, this.color, gameState.getContext())\n  }\n\n}","\n// @ts-check\nimport { gameState } from '../App'\nimport { canvasHeight, canvasWidth } from '../canvas/canvas'\nimport { drawCircle, drawRect } from './draw-functions'\nimport { Projectile } from './projectile'\nimport { Sprite } from './sprite'\n// @ts-ignore\nexport const collision = (objA: any, objB: any) => {\n  const objAtop = objA.y - objA.height\n  const objAbot = objA.y + objA.height\n  const objAleft = objA.x - objA.width\n  const objAright = objA.x + objA.width\n\n  const objBtop = objB.y - objB.height\n  const objBbot = objB.y + objB.height\n  const objBleft = objB.x - objB.width\n  const objBright = objB.x + objB.width\n\n\n  const collisionY = objAtop <= objBbot\n    && objAbot >= objBtop\n  const collisionX = objAleft <= objBright\n    && objAright >= objBleft\n\n  return collisionY && collisionX\n}\n\n\nexport function createProjectile (x: number, y: number, angle: number) {\n  const projectile = new Projectile(x, y, angle)\n  return projectile\n}\n\nexport function createFireEffect (x: number, y: number, angle: number, ctxs: CanvasRenderingContext2D | undefined) {\n  const width = 4\n  const height = 6\n  const projectile = new Sprite(x, y, angle, width, height, 'brown', 5)\n  projectile.draw = function() {\n    const ctx = gameState.getContext()\n    if (!ctx) return\n    ctx.save()\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    ctx.translate(-x, -y);\n\n    ctx.fillStyle = '#A9F4FF';\n    ctx.fillRect(x + 8, y, width, height)\n    ctx.restore()\n\n  }\n  return projectile\n}\n\nexport function createBlood (x: number, y: number, angle: number, width = 2, height = 2) {\n  const color = '#D64933'\n  const blood = new Sprite(x, y, angle, 2, 10, color)\n  const randomX = [\n    Math.random() * 10,\n    Math.random() * 10,\n    Math.random() * 10,\n    Math.random() * 10,\n    -Math.random() * 10,\n    -Math.random() * 10\n  ]\n  const randomWidth = [\n    Math.random() * 8,\n    Math.random() * 8,\n    Math.random() * 8,\n    Math.random() * 8,\n    Math.random() * 8\n  ]\n  blood.draw = function () {\n    const ctx = gameState.getContext()\n    if (!ctx) return\n    ctx.save()\n    ctx.translate(x, y)\n    ctx.rotate(angle)\n    drawCircle(0, 0, width, color, ctx)\n    drawCircle(randomX[0], randomX[0], randomWidth[0], color, ctx)\n    drawCircle(randomX[1], randomX[1], randomWidth[1], color, ctx)\n    drawCircle(randomX[2], randomX[2], randomWidth[2], color, ctx)\n    drawCircle(randomX[3], randomX[3], randomWidth[3], color, ctx)\n    drawCircle(randomX[4], randomX[4], randomWidth[4], color, ctx)\n    ctx.restore()\n  }\n  return blood\n}\n\nexport function createPickup (x: number, y: number, angle: number, width = 10, height = 10) {\n  const pickup = new Sprite(x, y, angle, width, height, 'purple')\n  return pickup\n}\n\nexport function degToRad (radians: number) {\n  return radians * Math.PI / 180\n}\n","import { canvasHeight, canvasWidth } from '../canvas/canvas';\nimport { drawCircle, drawRect } from './draw-functions';\nimport { createBlood, createFireEffect, createProjectile, createPickup } from './helper-functions'\nimport { createEnemy, drawMap, grid, gridCellSize, typeEnemy, createNewPlayer } from './index'\nimport { Player } from './player';\n\nconst playerColors = [\n  '#2f64ce',\n  '#13c13d',\n  '#1be4af',\n  '#7d239a',\n  '#9e8af6',\n  '#269ca7',\n  '#cdc18d',\n  '#c96732',\n  '#eba485',\n  '#7082d2',\n]\nconst bloodCanvas: HTMLCanvasElement = document.createElement('canvas')\n\nexport class GameState {\n  level: number;\n  enemies: any[];\n  enemyIndexToFindTarget: number;\n  projectiles: any[];\n  pickups: any[];\n  players: Player[];\n  blood: any[];\n  gameIsRunning: boolean;\n  hasStartedGame: boolean;\n  loop: any;\n  enemiesGridPositions: any[];\n\n  canvasWidth: number\n  canvasHeight: number\n\n  ctx?: CanvasRenderingContext2D\n  incWave: (wave: number) => void\n  enemyGroupToUpdate: number\n\n  constructor () {\n    this.level = 1;\n    this.enemies = [];\n    this.enemyIndexToFindTarget = 0\n    this.projectiles = [];\n    this.pickups = []\n    this.players = []\n    this.blood = []\n    this.gameIsRunning = true\n    this.hasStartedGame = false\n    this.loop = null\n    this.enemiesGridPositions = [] // array of array\n\n    this.canvasWidth = canvasWidth\n    this.canvasHeight = canvasHeight\n    bloodCanvas.width = canvasWidth\n    bloodCanvas.height = canvasHeight\n    this.enemyGroupToUpdate = 0\n\n    this.incWave = () => {}\n  }\n\n  setContext = (ctx: CanvasRenderingContext2D) => {\n    this.ctx = ctx\n  }\n\n  getContext = (): CanvasRenderingContext2D | undefined => {\n    return this.ctx\n  }\n\n  setStartEnemiesGridPositions () {\n    this.enemiesGridPositions = new Array(grid.length)\n    const length = this.enemiesGridPositions.length\n    for (let i = 0; i <= length -1; i++) {\n      // this.enemiesGridPositions.fill([]) doesnt work because it seems to set every [] as same reference or something, interesting\n      // this.enemiesGridPositions[i] = []\n    }\n  }\n\n  addToEnemiesGridPositions (index: number, enemy: any) {\n    if (index >= 0 && index < grid.length) {\n      grid[index].type = typeEnemy\n      grid[index].enemy = enemy\n    }\n  }\n\n  removeFromEnemiesGridPositions (index: number, enemyId: any) {\n    if (grid[index] === undefined) console.log('UNDEFINED INDEX')\n    if (grid[index] === undefined) return\n    if (grid[index].type === typeEnemy && grid[index].enemy?.id === enemyId) {\n      grid[index].type = ''\n      grid[index].enemy = undefined\n      \n    }\n  }\n\n  update = () => {\n    \n    this.players.forEach((x) => x.update())\n    this.getProjectiles().forEach(sprite => sprite.update())\n    // Not everybody needs to update on every frame\n    // Try split into groups\n    const part = Math.floor(this.enemies.length / 4)\n    switch (this.enemyGroupToUpdate) {\n      case 0: {\n        for (let i = 0; i < part; i++) {\n          this.enemies[i].update()  \n        }\n        this.enemyGroupToUpdate = 1\n        break\n      }\n      case 1: {\n        for (let i = part; i < this.enemies.length; i++) {\n          this.enemies[i].update()  \n        }\n        this.enemyGroupToUpdate = 2\n        break\n      }\n      case 2: {\n        for (let i = part * this.enemyGroupToUpdate; i < this.enemies.length; i++) {\n          this.enemies[i].update()  \n        }\n        this.enemyGroupToUpdate = 3\n        break\n      }\n      case 3: {\n        for (let i = part * this.enemyGroupToUpdate; i < this.enemies.length; i++) {\n          this.enemies[i].update()  \n        }\n        this.enemyGroupToUpdate = 0\n        break\n      }\n    }\n    \n    // this.enemies.forEach(sprite => sprite.update())\n    this.blood.forEach(sprite => sprite.update())\n    this.removeEnemies()\n    this.removeProjectiles()\n    this.removePickups()\n    if (this.enemies[this.enemyIndexToFindTarget]) {\n      this.enemies[this.enemyIndexToFindTarget].findClosestTarget()\n    }\n    this.enemyIndexToFindTarget++\n    if (this.enemyIndexToFindTarget > this.enemies.length) {\n      this.enemyIndexToFindTarget = -100\n    }\n    if (this.enemies.length <= 0) {\n      \n      this.incLevel()\n      this.incEnemies()\n    }\n  }\n\n  draw = () => {\n    if (!this.gameIsRunning) {\n      // draw is called once after showStartScreen. \n      // Should be able to fix that but gameIsRunning boolean is easy-fix\n      console.log('this game is not running')\n      return\n    }\n    drawRect(0, 0, this.canvasWidth, this.canvasHeight, '#2B303A', this.ctx)\n    this.ctx?.drawImage(bloodCanvas,0,0,this.canvasWidth, this.canvasHeight)\n    \n    // this.blood.forEach(sprite => sprite.draw())\n    // this.getPickups().forEach(sprite => sprite.draw())\n    drawMap(this.ctx) // drawMap draws enemies\n    this.getProjectiles().forEach(sprite => sprite.draw())\n    // this.enemies.forEach((x) => x.draw())\n    this.players.forEach((x) => x.draw())\n\n  }\n\n  drawStartScreen = (firstRun?: boolean) => {\n    if (!this.ctx) return\n    drawRect(0, 0, this.canvasWidth, this.canvasHeight, 'grey', this.ctx)\n    drawMap(this.ctx)\n  }\n  \n  addPlayer = ( name: string, advance: string, turnRight: string, back: string, turnLeft: string, fire: string, playerHp: number, element: any) => {\n    const color = playerColors[this.players.length]\n    const player = createNewPlayer(\n      name, \n      this.canvasWidth / 2 + 10 * this.players.length, \n      this.canvasHeight / 2, \n      color, \n      'red', \n      undefined, \n      undefined,\n      undefined,\n      playerHp)\n    player.addKeyListeners(element)\n    player.setUpControls(advance, turnRight, back, turnLeft, fire)\n    this.players.push(player)\n  }\n\n  pause = () => {\n    if (this.loop) {\n      window.clearInterval(this.loop)\n      this.loop = null\n      this.gameIsRunning = false\n    } else {\n      this.gameIsRunning = true\n      this.loop = setInterval(() => {\n        this.update()\n        this.draw()\n      }, 30)\n    }\n  }\n\n\n  startGame = () => {\n    console.log('start!');\n    this.enemies = [];\n    this.projectiles = [];\n    this.blood = []\n    bloodCanvas.getContext('2d')?.clearRect(0, 0, canvasWidth, canvasHeight)\n    this.players.forEach((x) => {\n      x.reset()\n      x.resurrect()\n    })\n    // this.setStartEnemiesGridPositions()\n    this.gameIsRunning = true\n    this.incEnemies()\n    if (this.loop) {\n      window.clearInterval(this.loop)\n    }\n\n    this.loop = setInterval(() => {\n      this.update()\n      this.draw()\n    }, 30)\n  }\n\n  stopGame () {\n    this.gameIsRunning = false\n    this.players.forEach((x) => {\n      x.removeEventListeners()\n    })\n    clearInterval(this.loop)\n    this.drawStartScreen()\n  }\n\n  incProjectiles (x: number, y: number, angleRadian: number) {\n    // const randAngle = angle + (Math.random() / 30 - Math.random() / 30)\n    const randAngle = angleRadian\n    const newProjectile = createProjectile(x, y, randAngle)\n    this.projectiles.push(newProjectile)\n  }\n\n  incPickup (x: number, y: number) {\n    this.pickups.push(createPickup(x, y, 0))\n  }\n\n  getPickups () {\n    return this.pickups\n  }\n\n  removePickups () {\n    // this.pickups = this.pickups.filter((s) => s.isAlive())\n  }\n  \n\n  removeProjectiles () {\n    this.projectiles = this.projectiles.filter(x => x.isAlive())\n  }\n\n  incEnemies () {\n    // Should not inc all enemies at once. \n    // No need to add enemies when there's more than there's room for. \n\n    const numberOfEnemies = 100 * this.level * this.players.length\n    const directions = ['top', 'right', 'bot', 'left']\n    const extraDistance = 0\n    const maxRandDistance = 200\n    const getX = (direction: string) => {\n      \n      let x = 0\n      if (direction === 'top' || direction === 'bot') {\n        x = Math.random() * this.canvasWidth\n      } else if (direction === 'left') {\n        x = Math.random() * -maxRandDistance - extraDistance\n      } else if (direction === 'right') {\n        x = this.canvasWidth + (Math.random() * maxRandDistance) + extraDistance\n      }\n      return Math.floor(x)\n    }\n\n    const getY = (direction: string) => {\n      \n      let y = 0\n      if (direction === 'left' || direction === 'right') {\n        y = Math.random() * this.canvasHeight\n      } else if (direction === 'top') {\n        y = Math.random() * -maxRandDistance - extraDistance\n      } else if (direction === 'bot') {\n        y = this.canvasHeight + (Math.random() * maxRandDistance) + extraDistance\n      }\n      return Math.floor(y)\n    }\n    \n    const random = Math.floor(Math.random() * this.players.length)\n    const target = this.players[random]\n\n    for (let i = 0; i < numberOfEnemies; i++) {\n      const direction = directions[Math.floor(Math.random() * 4)]\n      const x = getX(direction)\n      const y = getY(direction)\n      this.enemies.push(createEnemy(x, y, gridCellSize, gridCellSize, target))\n    }\n\n    \n  }\n\n  incBlood (x: number, y: number, angle: number, width: number, height: number) {\n    const newX = x +  Math.floor(Math.random() * 3) -1\n    const newY = y +  Math.floor(Math.random() * 3) -1\n    // this.blood.push(createBlood(newX, newY, angle))\n    const ctx = bloodCanvas.getContext('2d')\n    if (!ctx) return\n    drawCircle(x, y, width, '#D64933', ctx)\n    return \n\n    // Random blood spatter might not be important when size is so small?\n    // const randomX = [\n    //   Math.random() * 10,\n    //   Math.random() * 10,\n    //   Math.random() * 10,\n    //   Math.random() * 10,\n    //   -Math.random() * 10,\n    //   -Math.random() * 10\n    // ]\n    // const randomWidth = [\n    //   Math.random() * 8,\n    //   Math.random() * 8,\n    //   Math.random() * 8,\n    //   Math.random() * 8,\n    //   Math.random() * 8\n    // ]\n    // const color = '#D64933'\n    // const ctx = bloodCanvas.getContext('2d')\n    // if (!ctx) return\n\n    // ctx.save()\n    // ctx.translate(x, y)\n    // ctx.rotate(angle)\n    // ctx.fillStyle = color;\n\n    // drawCircle(randomX[0], randomX[0], randomWidth[0], color, ctx)\n    // drawCircle(randomX[1], randomX[1], randomWidth[1], color, ctx)\n    // drawCircle(randomX[2], randomX[2], randomWidth[2], color, ctx)\n    // drawCircle(randomX[3], randomX[3], randomWidth[3], color, ctx)\n    // drawCircle(randomX[4], randomX[4], randomWidth[4], color, ctx)\n    // ctx.restore()\n  }\n\n  getBlood () {\n    return this.blood\n  }\n\n  removeEnemies () {\n    this.enemies = this.enemies.filter(x => x.isAlive())\n  }\n\n  getLevel () {\n    return this.level\n  }\n\n  incLevel () {\n    console.log('NEW LEVEL');\n    this.level++\n    this.incWave(this.level)\n    this.players.forEach((x) => x.resurrect())\n\n  }\n\n  getEnemies () {\n    return this.enemies\n  }\n\n  getProjectiles () {\n    return this.projectiles\n  }\n\n}\n\n","import React, { useEffect, useRef, useState } from 'react'\nimport { Canvas } from './canvas/canvas';\nimport { GameState } from './game/game-state';\nimport styled, { css } from 'styled-components';\nimport { InGameMenu } from './menu/in-game-menu';\nimport { grid } from './game';\nconst Wrapper = styled.div<{ hasStarted?: boolean }>`\n  text-align: center;\n  height: 100vh;\n  width: 100vw;\n  overflow: hidden;\n\n  ${({ hasStarted }) => hasStarted && css`\n    background: #1f2229;\n    background: #1f2229cf;\n  `};\n\n  div {\n    margin: 8px;\n  }\n`\nexport let gameState: GameState\n\ntype PlayerData = {\n  name: string,\n  advance: string,\n  turnRight: string,\n  back: string,\n  turnLeft: string,\n  fire: string\n}\nfunction App() {\n  const [playersData, setPlayersData] = useState<PlayerData[]>([\n    {\n      name: 'Player 1 default',\n      advance: 'w',\n      turnRight: 'd',\n      turnLeft: 'a',\n      back: 's',\n      fire: 'u'\n    }\n  ])\n  const [nameValue, setNameValue] = useState('')\n  const [advanceControl, setAdvanceControl] = useState('')\n  const [turnRightControl, setTurnRightControl] = useState('')\n  const [turnLeftControl, setTurnLeftControl] = useState('')\n  const [moveBackwardsControl, setMoveBackwardsControl] = useState('')\n  const [fireControl, setFireControl] = useState('')\n  const ref = useRef<HTMLDivElement>(null)\n  const [hasStarted, setHasStarted] = useState(false)\n  const [playerHp, setPlayerHp] = useState(3)\n  const [showInGameMenu, setShowInGameMenu] = useState(false)\n  const [showCanvas, setShowCanvas] = useState(false)\n  \n\n  useEffect(() => {\n    if (hasStarted) {\n      console.log('startGame', playersData)\n      gameState = new GameState()\n      console.log('gameState new');\n      \n      const element = ref.current\n      playersData.forEach((player) => {\n        const { name, advance, turnRight, back, turnLeft, fire } = player\n        gameState.addPlayer(name, advance, turnRight, back, turnLeft, fire, playerHp, element)\n\n      })\n      setShowCanvas(true)\n      gameState.startGame()\n    }\n  }, [hasStarted, playersData, playerHp])\n\n  useEffect(() => {\n    const handlePause = (e: any) => {\n      if (showCanvas) {\n        if (e.key === 'Escape') {\n          setShowInGameMenu(gameState.gameIsRunning)\n          gameState.pause()\n        }\n        if (e.key === 'p') {\n          setShowInGameMenu(false)\n        }\n      }\n      \n    }\n    \n    ref.current?.addEventListener(('keydown'), handlePause)\n    \n    return () => ref.current?.removeEventListener('keydown', handlePause)\n  }, [showCanvas])\n\n  const startGame = () => {\n    if (!hasStarted) {\n      setHasStarted(true)\n    }\n  }\n\n  const addPlayer = () => {\n    \n    const newPlayer = {\n      name: nameValue,\n      advance: advanceControl,\n      back: moveBackwardsControl,\n      turnRight: turnRightControl,\n      turnLeft: turnLeftControl,\n      fire: fireControl\n    }\n    const updatedPlayers = [...playersData, newPlayer]\n    setPlayersData(updatedPlayers)\n  }\n\n  const resetInputFields = () => {\n    setNameValue('')\n    setAdvanceControl('')\n    setMoveBackwardsControl('')\n    setTurnRightControl('')\n    setTurnLeftControl('')\n    setFireControl('')\n  }\n\n  const onSubmit = (e: React.FormEvent) => {\n    e.preventDefault()\n    addPlayer()\n\n    resetInputFields()\n    \n  }\n  const removePlayer = (name: string) => {\n    const players = playersData.filter((x) => x.name !== name) \n    setPlayersData(players)\n  }\n  const resetGrid = () => {\n    grid.forEach((x, i) => {\n      grid[i] = {\n        ...x,\n        type: '',\n        background: '',\n        enemy: undefined,\n        player: undefined\n      } \n    })\n  }\n\n  const restart = () => {\n    console.log('restart');\n    gameState.stopGame()\n    resetGrid()\n    \n    setShowCanvas(false)\n    setShowInGameMenu(false)\n    gameState.startGame()\n    setShowCanvas(true)\n    // setTimeout(() => {\n    //   gameState.startGame()\n    //   setShowCanvas(true)\n    // }, 1000)\n\n  }\n\n  const quit = () => {\n    gameState.stopGame()\n    resetGrid()\n    setShowInGameMenu(false)\n    setShowCanvas(false)\n    setHasStarted(false)\n  }\n\n  const disableAddPlayer = \n    nameValue.length <= 0 \n    || advanceControl.length <= 0 \n    || moveBackwardsControl.length <= 0 \n    || turnRightControl.length <= 0 \n    || turnLeftControl.length <= 0 \n    || fireControl.length <= 0 \n\n  return (\n    <Wrapper\n      ref={ref}\n      hasStarted={hasStarted}\n      tabIndex={0}\n      >\n        {showCanvas ? <Canvas gameState={gameState} /> : (\n          <div>\n          {/* <div>Player hp (For dev purpose): <input type='number' onChange={(e) => setPlayerHp(Number(e.target.value))} value={playerHp}/></div> */}\n              <div>\n                <div>Name:</div>\n                <input type=\"text\" placeholder='Add name' value={nameValue} onChange={(e) => setNameValue(e.target.value)} />\n                </div>\n              <div>Controls</div>\n              <div>\n                <div>Advance:</div>\n                <input type=\"text\" placeholder='' value={advanceControl} onKeyDown={(e) => setAdvanceControl(e.key)} />\n              </div>\n              <div>\n                <div>Turn right:</div>\n                <input type=\"text\" placeholder='' value={turnRightControl} onKeyDown={(e) => setTurnRightControl(e.key)} />\n              </div>\n              <div>\n                <div>Turn left:</div>\n                <input type=\"text\" placeholder='' value={turnLeftControl} onKeyDown={(e) => setTurnLeftControl(e.key)} />\n              </div>\n              <div>\n                <div>Move backwards:</div>\n                <input type=\"text\" placeholder='' value={moveBackwardsControl} onKeyDown={(e) => setMoveBackwardsControl(e.key)} />\n              </div>\n              <div>\n                <div>Fire:</div>\n                <input type=\"text\" placeholder='' value={fireControl} onKeyDown={(e) => setFireControl(e.key)} />\n              </div>\n\n            <button onClick={resetInputFields}>Cancel</button>\n            <button onClick={onSubmit} disabled={disableAddPlayer}>Add Player</button>\n            <div>Players:</div>\n            {playersData.map((x) => <div>\n              {JSON.stringify(x)}\n              <button onClick={() => removePlayer(x.name)}>Remove {x.name}</button>\n            </div>)}\n            {playersData.length > 0 && (\n              <div>\n                <button onClick={startGame}>start game</button>\n              </div>\n            )}\n            \n        </div>\n        )}\n        {showInGameMenu && <InGameMenu restart={restart} quit={quit} />}\n    </Wrapper>\n  );\n}\n\nexport default App;\n","import styled from 'styled-components';\n\nexport const MenuWrapper = styled.div`\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n`\n\nexport const MenuItem = styled.div`\n  font-size: 48px;\n  color: #0C7C59;\n  color: #A9F4FF;\n  color: #BAC1B8;\n  cursor: pointer;\n  &:hover {\n    color: #edefed;\n  }\n`","import React from \"react\"\nimport {MenuWrapper, MenuItem} from './menu-styles'\n\ntype Props = {\n  restart: () => void\n  quit: () => void\n}\n\nexport const InGameMenu = ({ restart, quit}: Props) => {\n  return (\n    <MenuWrapper>\n      <MenuItem onClick={restart}>Restart</MenuItem>\n      <MenuItem onClick={quit}>Quit</MenuItem>\n    </MenuWrapper>\n  )\n}","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}